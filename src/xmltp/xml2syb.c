/* xml2syb.c
 * ---------
 *
 *
 *  Copyright (c) 2001-2003 Jocelyn Blanchet
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Library General Public
 *  License as published by the Free Software Foundation; either
 *  version 2 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Library General Public License for more details.
 *
 *  You should have received a copy of the GNU Library General Public
 *  License along with this library; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *  (The file "COPYING" or "LICENSE" in a directory above this source file
 *  should contain a copy of the GNU Library General Public License text).
 *  -------------------------------------------------------------------------
 *
 * $Source: /ext_hd/cvs/xmltp/xml2syb.c,v $
 * $Header: /ext_hd/cvs/xmltp/xml2syb.c,v 1.37 2006-05-17 16:50:33 toucheje Exp $
 *
 *
 * xml2syb.c: XML-TP to Sybase gateway
 * ---------
 *
 * -----------------------------------------
 * This module implements the "xml2db.h" API.
 * ------------------------------------------
 *
 * This is a CT-Lib client programr, it uses the ct10api high-level library.
 *
 * LIST OF SUPPORTED FEATURES
 * **************************
 *
 * Use ct10api for the sybase side. All retry are disable in ct10api. 
 * xml2syb handle some retry if no result begin and only inside the 10 first seconds.
 * Maximum timeout is 110seconds. 10 initial seconds plus 100 seconds. 
 *
 * intercept xid for monitors	**** DONE 90%  Rest to build a complete config file *****
 *	*New order: ord_id=150203120, dst=7, type=0 - from spid= 176.
 *	*New TICS Request: 8342087 OK, queued to be sent. spid= 121.
 *	*New trade: 42524689 OK, queued to be sent. spid= 49.
 *	From Java not needed here:
 *	*New price feed: trade_date=2001/11/01 00:00:00, seq_no=444, sec_id_flag=1, sec_id=135087XB5   ; first protocol
 *
 * log of rpc_audit.log		   
 * log of playback assign sequence 
 * Accumulate stats info 	   **** NOT DONE *****
 *
 * input, output parameters
 * Multi result set
 * Return nb rows of each result set
 * SP return status 
 * int, char, float, date
 * server messages
 *
 * Limitation of row count (2005) with ct_option before each sp call
 *
 * Return a maximum of 20 messages
 *
 * TO BE DONE 
 * **********
 *
 * CHECK ALL THE FIELD IN oesyssrv.log and rpc_audit.log 
 * clean config for xid
 *
 * --------------------------------------------------------------------------
 * Versions:
 * 2001sept04,jft: first version (based on kick_timeout.c)
 * 2001sept05,jft: added xml2db_xxx() functions required for first prototype
 * 2001sept06,jft: + xml2db_get_name_of_param(), fix compile errors
 * 2001sept10,jft: add -X command line argument, use xmltp_ctx_fill_input_buffer()
 * 2001sept10,jft: + sf_init_master_socket_listen()
 * 2001sept11,jft: + call xmltp_ctx_assign_log_function_pf()
 * 2001sept12,jft: + sf_process_row(): it calls xmltp_writer_XXX()
 * 2001sept14,jft: . sf_process_client_connection(): write to log when stopping
 * 2001oct09,jft: added #include "xmltp_writer.h"
 *		  . sf_process_row(): xmltp_writer_note_error(p_ctx, cnv_buff);
 * 2001oct16,jbl: added support for NBROWS of each result set
 *		  Capture nbrows in a static. Pass nbrows to:
 *			xmltp_writer_begin_output_params, 
 *			xmltp_writer_end_response,
 *			xmltp_writer_begin_result_set
 * 2001oct16,jbl: added support for error messages
 *		   + support for oesyssrv.log
 *		   + begin of support for standard return status -1100, -1105, ...
 * 2001nov01,jbl: added registered procedure RP_DB_LOGIN
 * 2001nov14,jbl: added oesyssrv.log + rpc_audit.log
 * 2001nov28,jbl: added support for xid (New order, New TICS, new trade).
 * 2002jan08,jft: . sf_process_client_connection(): pass p_ctx as argument to yyparse(p_ctx),
 *			this allows to use the re-entrant parser generated by Bison
 *		  . sf_process_client_connection(): calls xmltp_ctx_get_b_eof_disconnect(p_ctx)
 *			to know if client has disconnected. If so, set rc = 1 to indicate disconnect.
 * 2002jan09,jbl: . Retrofit jft changes from 2002jan08. I made a few changes on nov28 that were not
 *		    included in jft version.
 *		  . Fix linux crash problem in sf_format_cs_data_value.
 * 2002feb28,jbl: Fix date output format problem.
 *			use ct10api_convert_date_to_string_std to replace cs_convert.
 *		  Rework the yyparse loop in sf_process_client_connection.
 * 2002mar25,jft: added regproc "xml2db_ping" which simply return a return status == 0
 *		  added regprocs "xml2db_debug_low", "xml2db_debug_full", "ping"
 * 2002jun03,jbl: added opt_size to xml2db_create_param_struct.
 *		  added size to xmltp_writer_column_name and
 *		   xmltp_writer_param_value
 * 2002aug04,jbl: Finish clean return stats, timeout and retry
 * 2002aug08,jbl: Added: xmltp_decode in xml2db_create_param_struct.
 * 		  remove some log entries.
 * 2002aug11,jbl: lock rpc_audit, fix len of char output param.
 * 2002nov04,deb: + mode mask for the open() call in sf_write_to_rpc_audit()
 * 2003jan23,jft: removed #include "defpaths.h" as none of its constants are used.
 *                removed #include "getline1.h" as g1ln_get_first_line_of_file() is not used.
 *                removed #include "lbospar1.h", instead, added #define PAR_LOG_FILENAME
 *                and #define PAR_CLT_APPL_NAME
 * 2003jan31,jbl: Cleanup all compilation warning on linux.
 * 2003feb04,jbl: Reuse socket on open.
 * 2003feb06,jbl: sf_delta_tval_in_ms: Fix milliseconds problems in xmltp_audit.log
 * 		  Fix row count in the logs now is total of all result set + 1 (for the status row)
 *		  Added: xmltp_hosts support
 * 2003feb14,jbl: Integrated JF LGPL modifications.
 *		  Clean some comments.
 * 2003mar11,jft: xml2db_abort_program(): if last arg is "0", do not write to log (unless low trace level enabled).
 *		  sf_process_client_connection(): do NOT write Error msg in log if xmltp_ctx_get_b_eof_disconnect(p_ctx), that's a normal condition.
 *		  sf_kill_process(): write ALOG_INFO msg to log if kill fail (99% of times, it fails).
 * 2003jul10,jbl: Add ct10api_set_row_count that use ct_option (to replace init string to set rowcount)
 * 2003aug29,jbl: Force a reconnect when ct10reco ask for RECOV_ACT_RESET_CONNECTION before a retry
 * 2004feb01,tb:  Added: Any error on cs_convert when converting SP params will return a FATAL return stats.
 * 		  In that case the stored proc wont be executed. A static global was needed: s_params_err_ind.
 * 2004mar30,jbl: move s_params_err_ind=0 inside the yyparse loop. We need to reset it for each SP call.
 * 2004mar30,jbl: Never return a return stats from sybase. Always try to analyse info from ct10reco to
 * 		  return a valid return stats, unknowned error will always return -1105.
 * 2004avr20,jbl: Add support for numeric type.
 * 2004apr22,deb: Changed datatype mapping in sf_convert_to_jdbc_datatype() to return a smaller subset
 *                of datatypes: INT, FLOAT, TIMESTAMP and VARCHAR
 * 2004nov02,deb: removed test on rc from this line:
 *		  if ( ( rc == CT10_SUCCESS ) && ( return_status != -999) )
 *		  to fix overwrite of sybase return status for duplicate keys and others....
 * 2005feb07,jbl: s_exec_timeout value comes from EXEC_TIMEOUT config param or from command line -t arg. And a few more fixes.
 * 2005sep11,jft: xml2db_exec_proc(): retry is return_status is one of those to retry
 *		  sf_return_status_is_one_to_retry()
 * 2005dec05,jft: MAX_NB_MESSAGES   100 (was 20)
 * 2006mai17,jft: fixed ARGUMENTS_STRING as "H:F:C:S:U:P:I:A:D:L:X:R:r:d:t:" (was missing r: )
 *		  added #ifdef DEBUG_GET_ROWCOUNT_LIMIT	 with debugging code
 */


#define _INCLUDE_XOPEN_SOURCE_EXTENDED

#ifndef LINUX

#ifndef _INCLUDE_HPUX_SOURCE
#define _INCLUDE_HPUX_SOURCE
#include <time.h>       	/* for time_t, struct timeval */
#undef  _INCLUDE_HPUX_SOURCE
#else
#include <time.h>       	/* for time_t, struct timeval */
#endif

#else
#include <sys/time.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#endif

#include <stdio.h>
#include <stdlib.h>		/* for calloc(), free(), ... */
#include <unistd.h>		/* for sleep() 	*/
#include <errno.h>

#include <sys/file.h>
#include <signal.h>

#include "ctpublic.h"		/* Sybase CTlib stuff */
#include "oserror.h"		/* for SRV_MAXERROR */

#include "common_1.h"		/* does #include of several common C headers */

#include "parse_argument.h"

#include "ct10api.h"
#ifdef VERSION_ID
#undef VERSION_ID		/* ct10api.h does #define of VERSION_ID, should not */
#endif

#include "ct10reco.h"		/* Ct10api recovery module stuff */
#include "ct10init.h"		/* High level ct10api init stuff */
#include "rpc_null.h"		/* NULL string for all datatype */

#include "ucfg.h"

#include "alogelvl.h"
#include "apl_log1.h"
#include "errutl_1.h"		/* for errutl_severity_to_alog_err_level() */
#include "linklist.h"		/* for lkls_xxx() functions */

#include "osclerr1.h"		/* for OSCLERR_CONNECT_FAILED */

#include "ct10str.h"		/* for ct10strncpy() */

#include "sock_fn.h"		/* for sock_XXX() */
#include "sockpara.h"		/* for #define SOCKPARA_xxx */

#include "xmltp_lex.h"		/* for xmltp_lex_get_single_thread_context() */
#include "xmltp_parser.h"	/* for xmltp_ctx_fill_input_buffer() */
#include "xmltp_writer.h"	/* for xmltp_writer_xxx() functions */

#include "javaSQLtypes.h"	/* for JAVA_SQL_CHAR, ... */
#include "xml2db.h"		/* xml2db_XXX() functions prototypes */
#include "xmltp_hosts.h"	/* logical name, host name, port number */

#include <strings.h>

/* ------------------------------------ Things not found in #include :  */

#ifndef LINUX
extern	char	*sys_errlist[];
#endif

/* ----------------------------------------------- Private Defines: */

/*
 * Usage and Version info:
 */
#define VERSION_NUM	"0.9.1"

#ifdef VERSION_ID
#undef VERSION_ID
#endif
#define VERSION_ID	\
		(__FILE__ " " VERSION_NUM " - " __DATE__ " - " __TIME__)


/*
 * Application specific constants:
 */
#define APPNAME_IN_LOG_FILE		"xml2syb"

#define SET_ROWCOUNT_SQL_STRING		"set rowcount "
#define DEFAULT_ROWCOUNT_VALUE		"2000"


#define CFG_SECTION			"XML2SYB"
#define PAR_ERRORS_TO_IGNORE		"ERRORS_TO_IGNORE"
#define PAR_LOG_FILENAME		"LOG_FILENAME"
#define PAR_CLT_APPL_NAME		"CLT_APPL_NAME"


/*
 * Limits:
 */

#define MAX_SYB_VALUE_SIZE		256
#define MAX_SYB_NB_PARAMS		256

#define MAX_RETRY_TIME_MS		10000	/* 10 seconds */
#define MAX_RETRY_COUNT			3
#define EXEC_TIMEOUT			100

#define WORK_BUFFER_SIZE		256


/*
 * Define for ct10init
 * See syntax() function for details
 */

#define ARGUMENTS_STRING "H:F:C:S:U:P:I:A:D:L:X:R:r:d:t:"

/* Options not included in ct10init */

#define ARG_XMLTP_HOST_LOGICAL_NAME 		'H'
#define CONFIG_STRING_XMLTP_HOST_LOGICAL_NAME	"XMLTP_HOST_LOGICAL_NAME"

#define ARG_RPC_AUDIT_LOG_NAME 			'R'
#define CONFIG_STRING_RPC_AUDIT_LOG_NAME	"RPC_AUDIT_LOG_FILE_NAME"

#define ARG_APPL_DEBUG_TRACE_LEVEL 		'd'
#define CONFIG_STRING_APPL_DEBUG_TRACE_LEVEL	"APPL_DEBUG_TRACE_LEVEL"

#define ARG_ROWCOUNT_LIMIT 			'r'
#define CONFIG_STRING_ROWCOUNT_LIMIT		"ROWCOUNT_LIMIT"

#define ARG_EXEC_TIMEOUT 			't'
#define CONFIG_STRING_EXEC_TIMEOUT		"EXEC_TIMEOUT"

#define CONFIG_STRING_RPC_TO_INTERCEPT_XID	"RPC_TO_INTERCEPT_XID"
#define CONFIG_STRING_RESULT_SET_INTERCEPT_FOR	"RESULT_SET_INTERCEPT_FOR_"
#define CONFIG_STRING_COLUMN_INTERCEPT_FOR	"COLUMN_INTERCEPT_FOR_"
#define CONFIG_STRING_STRING_TO_LOG_FOR		"STRING_TO_LOG_FOR_"

#define CONFIG_STRING_RETRY_ON_THOSE_RETURN_STATUS	"RETRY_ON_THOSE_RETURN_STATUS"


#define XID_STRING_TO_LOG_LEN			100
#define XID_DEFAULT_STRING_TO_LOG		"*New CONFIG ERROR: "

/*
 * SYBASE LANG environment variable must be set
 * before running xml2syb. LANG variable is also
 * use by OS like HP-UX but the value is not the same.
 * Value specific to sybase must be set before
 * running xml2syb. All client using XML stream from 
 * xml2syb must be ISO. We could but we dont support ROMAN 8.
 * The caracter set conversion is handle between SYBASE and
 * xml2syb not other conversion will be done after...
 * On linux we dont need to set the LANG because it 
 * is already ISO. This part could be removed.
 * It's not use anymore.
 */

#ifndef LINUX
#define SYBASE_LANG_STRING 	"french.iso88591"
#else
#define SYBASE_LANG_STRING 	"FRENCH"
#endif

#define SYBASE_LANG_VAR		"LANG"




/*
 * Required to replace return stat from RPC
 * for specific error or if no return stat
 * is available.
 */

#define RPC_RETURN_STAT_FOR_NO_DS_CONN		-1100
#define RPC_RETURN_STAT_FOR_TIMEOUT		-1101
#define RPC_RETURN_STAT_FOR_FATAL		-1105
#define RPC_RETURN_STAT_FOR_DEADLOCK		-1205
#define RPC_RETURN_STAT_FOR_OTHER_ERROR 	-1199
#define	RPC_RETURN_STAT_FOR_SUCCESS		 0

#define	CT10_RESULT_NOT_PRESENT                 0x0001

/*
 * Registered procedure stuff...
 */

#define MSG_BUFF_SIZE			2048

#define REG_PROC_XML2DB_DEBUG_LOW	"xml2db_debug_low"		/* turn on Low debug level in xmltp_ctx.c */
#define REG_PROC_XML2DB_DEBUG_FULL	"xml2db_debug_full"		/* turn on Full debug level in xmltp_ctx.c */
#define REG_PROC_XML2DB_PING		"xml2db_ping"			/* simply send back return status == 0 */
#define REG_PROC_PING			"ping"				/* like "xml2db_ping", but NO logging */
#define REG_PROC_DB_LOGIN		"login"				/* Login, password to sybase + TRG name for log */
#define REG_PROC_KILL			"kill"				/* Kill a PID */

/* Not used */
#define REG_PROC_DB_LOGOUT		"logout"			/* Clean termination of xml2syb */
#define REG_PROC_DUMP_STAT		"dump_stats"			/* Dump stat to oesyssrv.log */
#define REG_PROC_RESET_STAT		"reset_stats"			/* Reset all stats counter to zero */
#define REG_PROC_SET_TRACE_LEVEL	"set_trace_level"		/* Change the trace level to allow prod debug */
#define REG_PROC_CHANGE_ROW_COUNT_LIMIT	"change_row_count_limit"	/* Required for Batch TRG to raise the limit */

#define RP_DB_LOGIN_PARAM_USERNAME_POSI	0
#define RP_DB_LOGIN_PARAM_PASSWORD_POSI	1
#define RP_DB_LOGIN_PARAM_TRG_NAME_POSI	2

#define RP_DB_LOGIN_PARAM_USERNAME_SIZE	12
#define RP_DB_LOGIN_PARAM_PASSWORD_SIZE	32
#define RP_DB_LOGIN_PARAM_TRG_NAME_SIZE	32

#define CT10_RESULT_PRESENT	0x0002

/* ----------------------------------------------- Global Variable: */

int		 g_debug = 0;		/* for xmltp_lex.c	*/


/* ----------------------------------------------- Private Variables: */

static int	 s_debug_level	   = DEBUG_TRACE_LEVEL_NONE;

static char	*s_pgm_name	   = __FILE__;

static char	s_user_name[RP_DB_LOGIN_PARAM_USERNAME_SIZE+1];

static int 	s_row_count;

/* 
 * Pointer to ct10api connection:
 */

static void	*s_p_server_conn = NULL;



/*
 * Current active connection...
 *
 * This pointer to a CT10_CONN_T should be updated
 * before each attempt to execute a RPC.
 *
 * It is used by sf_handle_error_msg() to find the name of the server.
 */
static void	*s_current_active_conn = NULL;


/*
 * Last result set nb rows from TDS
 * Will be set at the end of a result set but will be use
 * only at the beginning of the next result set.
 */

static int s_last_result_set_nb_rows = -1;


/* Timeout value from config or program argument */
static int s_exec_timeout;


/*
 * Stuff for messages callback support.
 * Limit number of messages to MAX_NB_MESSAGES.
 */

#define MAX_NB_MESSAGES		100
#define MSG_TEXT_SIZE		256
#define MISSING_MSG_STRING_1	"00000000: Info: Maximum number of messages reach, "
#define MISSING_MSG_STRING_2	" message(s) missing"

struct st_msg {
	int msg_num;
	char msg_text[MSG_TEXT_SIZE + 1];
};
typedef struct st_msg MSG_T;

static int	s_nb_msg = 0;
static MSG_T	s_msg_tab[MAX_NB_MESSAGES + 1];



/*
 * required static variables to logs oesyssrv.log
 * and rpc_audit.log. 
 *
 * To log rpc_audit.log we need to accumulate playback assign sequence
 * entry in a buffer during RPC execution. At the end we add the stored
 * proc itself before writing the buffer.
 */

static struct timeval    st_tval_begin_rpc;	/* Time of RPC start */
static struct timeval    st_tval_end_rpc;	/* Time of RPC end */
static int		 s_rpc_nb_rows;		/* Total number of rows for all results set */
static int		 s_rpc_return_status;	/* Stored procedure return status */

#define RPC_LINE_PREFIX 			"~~RPC="
#define RPC_PLAYBACK_SP_PREFIX 			"##@"
#define PLAYBACK_ASSIGN_SEQ_INTERCEPT_STRING 	"RPC_AUDIT_ENTRY="
#define MAX_RPC_AUDIT_LOG_BUFFER_SIZE 		24000
#define MAX_RPC_AUDIT_WORK_BUFFER_SIZE 		16000

static char rpc_audit_log_buffer[MAX_RPC_AUDIT_LOG_BUFFER_SIZE + 1];
static int  rpc_audit_buffer_posi=0;

static int  s_intercept_xid = FALSE;
static int  s_intercept_xid_result_set = 0;
static int  s_intercept_xid_column = 0;
static char s_xid_string_to_log[XID_STRING_TO_LOG_LEN+1];


/*
 * This indicate if we have a valid active database connection.
 * The default is FALSE (0).
 * The TRG-X must call a Registered proc to perform database
 * connection. Return stat of -1100 is return for any stored proc call
 * as long as a valid connection is not done.
 */

static int s_db_connection_is_active = 0;


/* Others static variables */

static char s_trg_name[RP_DB_LOGIN_PARAM_TRG_NAME_SIZE+1];	/* Use to log */
static char s_msg_buff[MSG_BUFF_SIZE+1]; 			/* Use to build log messages */
static int  s_timeout_ind = 0;
static int  s_params_err_ind = 0;				/* to carry cs_convert error on sp params */

/* xmltp_hosts related stuff */
#define ENV_XMLTP		"XMLTP"
#define PATH_SIZE		256
#define HOSTNAME_SIZE		256
#define LISTEN_PORT_SIZE	32
#define XMLTP_HOST_FILE_NAME	"xmltp_hosts"

static char	s_host_name[HOSTNAME_SIZE];
static char	s_listen_port[LISTEN_PORT_SIZE];

/* ----------------------------------------------- Private Functions: */




/*
 * All these params are require for database connection (ct10init module)
 *
 * Specific application options:
 *
 * -R: rpc audit log name
 *
 */

static void sf_syntax(char *pgm_name)
{

        fprintf(stderr,"\n");
        fprintf(stderr,"Syntax: %s <options>...\n", pgm_name);
        fprintf(stderr,"\n");
        fprintf(stderr,"Version: %s\n", VERSION_ID);
        fprintf(stderr,"\n");
        fprintf(stderr,"       options:\n");
        fprintf(stderr,"\n");
        fprintf(stderr,"       -H <xmltp_host logical name>\n");
        fprintf(stderr,"       -F <config File path and name>\n");
        fprintf(stderr,"       -C <Config file section>\n");
        fprintf(stderr,"       -S <Database Server name>\n");
        fprintf(stderr,"       -U <User name>\n");
        fprintf(stderr,"       -P <Password file path nad name>\n");
        fprintf(stderr,"       -I <Init string>\n");
        fprintf(stderr,"       -A <Application name>\n");
        fprintf(stderr,"       -D <CT10init debug trace mask >\n");
        fprintf(stderr,"            1) info only, 4294967295) full\n");
        fprintf(stderr,"       -d <xml2syb debug trace level>\n");
        fprintf(stderr,"            0)none, 1)low, 5)medium, 10)full, 15)detailed\n");
        fprintf(stderr,"       -L <Log file path and name>\n");
        fprintf(stderr,"       -r <rowcount limit (default 2000)>\n");
        fprintf(stderr,"       -t <timeout val in second>)>\n");
        fprintf(stderr,"\n");

} /* End of sf_syntax() */




/*
 * Copy from logrpcfn.c
 *
 * Format time value for log entry.
 *
 */

static int sf_format_usec_time( char  *edit_buffer, int buffer_sz,
                                unsigned long   t_sec,
                                long            t_usec)
{
        char    timwork[60];

        if (edit_buffer == NULL) {
                return (-1);
        }
        if (buffer_sz < 50) {
                return (-2);
        }

	memset(timwork, 0, sizeof(timwork) );

        strftime(timwork, sizeof(timwork), "%Y-%m-%d %H:%M:%S",
                 localtime( (time_t *) &(t_sec) ) );

        /* Concat miliseconds (usec / 1000) to date-time string
         * in the edit_buffer:
         */
        sprintf(edit_buffer, "%.44s:%03d",
                             timwork,
                             ( (t_usec + 499L) / 1000L) );

        return (0);

} /* End of sf_format_usec_time() */



/* 
 * Use to log regular message to oesyssrv.log.
 */

static void sf_write_error_to_log(int err_level, int msg_no, char *err_msg)
/*
 * Called by:	sf_handle_error_msg()
 *		sf_diag_rpc_exec_error()
 */
{
	alog_aplogmsg_write(err_level,
			    s_trg_name,
			    ct10init_get_option_or_config_value(
				CT10INIT_ARG_SERVER_NAME, 
				CT10INIT_CONFIG_STRING_SERVER_NAME),
			    msg_no,
			    ct10init_get_option_or_config_value(
				CT10INIT_ARG_USER_NAME, 
				CT10INIT_CONFIG_STRING_USER_NAME),
			    err_msg);

} /* End of sf_write_error_to_log() */



/*
 * Copy from logrpcfn.c
 *
 * Open rpc audit log file, write buffer and
 * close file.
 *
 */

int sf_write_to_rpc_audit( char *str )
{
        FILE     *fi_log = NULL;
	int	 fi = 0;

        /* Open log file
         */
	if ( (fi = open(
		ct10init_get_option_or_config_value(ARG_RPC_AUDIT_LOG_NAME, 
						CONFIG_STRING_RPC_AUDIT_LOG_NAME),
		O_WRONLY|O_APPEND|O_CREAT, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH
		 ) ) == -1 ) {

			sprintf(s_msg_buff,"sf_write_to_rpc_audit: open fail, errno[%d]", errno);
			sf_write_error_to_log(ALOG_ERROR, 0, s_msg_buff);

	}

        if (( fi_log = fdopen(fi,  "a")) == NULL) {
		sprintf(s_msg_buff,"sf_write_to_rpc_audit: fdopen fail, errno[%d]", errno);
		sf_write_error_to_log(ALOG_ERROR, 0, s_msg_buff);
	}

        if (fi != -1) {

		if (lockf(fi, F_LOCK, 0) != 0) {
			sprintf(s_msg_buff,"sf_write_to_rpc_audit: lock fail, errno[%d]", errno);
			sf_write_error_to_log(ALOG_ERROR, 0, s_msg_buff);
		}
	}

        /* if fopen() failed, write to stderr,
         * else write to normal log file...
         */
        if (fi_log == NULL) {

		fprintf(stderr, "%s.\n", str);
		fflush(stderr);

		sprintf(s_msg_buff,"sf_write_to_rpc_audit: fail, write to stderr instead");
		sf_write_error_to_log(ALOG_ERROR, 0, s_msg_buff);

        } else {

		fprintf(fi_log, "%s.\n", str);

		if (lockf(fi, F_ULOCK, 0) != 0) {
			sprintf(s_msg_buff,"sf_write_to_rpc_audit: unlock fail, errno[%d]", errno);
			sf_write_error_to_log(ALOG_ERROR, 0, s_msg_buff);
		}

                if (fclose(fi_log) != 0) {
			sprintf(s_msg_buff,"sf_write_to_rpc_audit: close fail, errno[%d]", errno);
			sf_write_error_to_log(ALOG_ERROR, 0, s_msg_buff);
		}
        }


        return (0);

} /* End of sf_write_to_rpc_audit() */




/*
 * Use to save the time at the start of a stored procedure.
 */

static void sf_save_start_time()
{
	struct timezone   tz_dummy;

	gettimeofday(&st_tval_begin_rpc, &tz_dummy );

	return;
} /* End of sf_save_start_time() */




/*
 * Use to save the time at the end of a stored procedure.
 */

static void sf_save_end_time()
{
	struct timezone   tz_dummy;

	gettimeofday(&st_tval_end_rpc, &tz_dummy );

	return;
} /* End of sf_save_end_time */




/*
 * This code is a copy from the cig-trg source code.
 * It is required to log duration of stored proc in milliseconds.
 */

static long sf_delta_tval_in_ms(struct timeval *p_tv1, struct timeval *p_tv2)
/*
 * Return difference tv2 - tv1 in ms (milliseconds)
 */
{
        struct timeval  delta;
	long	tv_usec, tv_sec;;

	tv_usec = p_tv2->tv_usec;
	tv_sec  = p_tv2->tv_sec;

 
        if (p_tv1->tv_usec > p_tv2->tv_usec) {
                tv_usec += 1000000;
                tv_sec--;
        }
        delta.tv_sec  = tv_sec  - p_tv1->tv_sec;
        delta.tv_usec = tv_usec - p_tv1->tv_usec;
 
        return (  (delta.tv_sec  * 1000L)
                + (delta.tv_usec / 1000L) );
 
} /* End of sf_delta_tval_in_ms() */



/* 
 * Use to log init message to oesyssrv.log.
 * Message with 2 separate strings.
 */

static void sf_log_init_msg(int err_level, int msg_no, char *msg1, char *msg2)
{
	char	msg_buff[CS_MAX_MSG + 500] = "initmsg?!";

	sprintf(msg_buff, "%.200s: %.200s", msg1, msg2);

	sf_write_error_to_log(err_level, msg_no, msg_buff);

} /* End of sf_log_init_msg() */
	



/*
 * Look like sf_log_init_msg but with bigger messages.
 */

static void sf_write_log_msg_mm(int err_level, int msg_no, char *msg1, char *msg2)
{
	char	msg_buff[CS_MAX_MSG + 600] = "msg?!";

	sprintf(msg_buff, "%.300s %.300s", msg1, msg2);

	sf_write_error_to_log(err_level, msg_no, msg_buff);

} /* End of sf_write_log_msg_mm() */




/*
 * Log of xid intercept order number.
 */

static void sf_log_xid(char *id)
{
	char	msg_buff[CS_MAX_MSG + 600] = "msg?!";

	sf_save_end_time();

	sprintf(msg_buff, 
	"%.8s,  %s%s OK, queued to be sent",	
		"xml2syb_",
		s_xid_string_to_log,
		id,
		"?",
		"?"
		);

	sf_write_error_to_log(ALOG_INFO, 0, msg_buff);

} /* End of sf_log_xid() */




/*
 * This function write the rpc completion message into oesyssrv.log
 * NOTE: rc_mask, spid are hardcoded to zero,
 *	 from is hardcoded to trgx
 */

static void sf_log_rpc(char *proc_name)
{
	char	msg_buff[CS_MAX_MSG + 600] = "msg?!";

	sf_save_end_time();

	sprintf(msg_buff, "%.8s,  End of '%.100s' %ld ms, from %s, spid=%d, stat=%d, %d rows - rc_mask=%ld",	
		"xml2syb_",
		proc_name,
		sf_delta_tval_in_ms(&st_tval_begin_rpc, &st_tval_end_rpc),
		"trgx",
		0,
		s_rpc_return_status,
		s_rpc_nb_rows,
		0);

	sf_write_error_to_log(ALOG_INFO, 0, msg_buff);

} /* End of sf_log_rpc() */




/*
 * Construct a config string entry from 2 strings
 * and convert to int the found value.
 */

static int sf_get_int_config_value_construct(
		char *config_string_1,
		char *config_string_2
) {
char work_buff[WORK_BUFFER_SIZE];
char    *p_tmp = NULL;
int	i;

	strcpy(work_buff, config_string_1);
	strncat(work_buff, config_string_2, sizeof(work_buff));

	p_tmp = ucfg_get_param_string_first(work_buff);

	if (p_tmp == NULL) {
		sprintf(s_msg_buff, "sf_get_int_config_value_construct: missing config entry [%.*s]",
			  sizeof(work_buff), work_buff );
		sf_write_error_to_log(ALOG_ERROR, 0, s_msg_buff);

		return (0);
	}
	else {
		i = 0;
		i = atoi(p_tmp);

		if (i == 0) {
			sprintf(s_msg_buff, "sf_get_int_config_value_construct: invalid config entry value [%.*s] [%.20s]",
			  	sizeof(work_buff), work_buff ,p_tmp);
			sf_write_error_to_log(ALOG_ERROR, 0, s_msg_buff);

			return (0);
		}
	}

	return (i);

} /* End of sf_get_int_config_value_construct() */





/*
 * Construct a config string entry from 2 strings
 * and return the value.
 */

static char *sf_get_string_config_value_construct(
		char *config_string_1,
		char *config_string_2
) {
char work_buff[WORK_BUFFER_SIZE];
char    *p_tmp = NULL;
char 	*empty_string = "\0";

	strcpy(work_buff, config_string_1);
	strncat(work_buff, config_string_2, sizeof(work_buff));

	p_tmp = ucfg_get_param_string_first(work_buff);

	if (p_tmp == NULL) {
		sprintf(s_msg_buff, "sf_get_string_config_value_construct: missing config entry [%.*s]",
			  sizeof(work_buff), work_buff );
		sf_write_error_to_log(ALOG_ERROR, 0, s_msg_buff);

		return empty_string;
	}
	else {
		return p_tmp;
	}

} /* End of sf_get_string_config_value_construct() */



/*
 * Check the config file for intercept xid proc.
 * set static required for interception.
 */

static void sf_check_and_set_intercept_xid(char *proc_name)
{
char work_buff[WORK_BUFFER_SIZE];
char	*p_tmp = NULL;

if (ucfg_is_string_in_param_values_list(
		CONFIG_STRING_RPC_TO_INTERCEPT_XID, 
		proc_name) ) {

	if ( (s_intercept_xid_result_set = sf_get_int_config_value_construct(
		CONFIG_STRING_RESULT_SET_INTERCEPT_FOR, proc_name) ) == 0) {

		return;
	}

	if ( (s_intercept_xid_column = sf_get_int_config_value_construct(
		CONFIG_STRING_COLUMN_INTERCEPT_FOR, proc_name) ) == 0) {

		return;
	}

	s_intercept_xid = TRUE;

	if ( sf_get_string_config_value_construct(
		CONFIG_STRING_STRING_TO_LOG_FOR, proc_name) != NULL) {

		strncpy(s_xid_string_to_log, sf_get_string_config_value_construct(
                CONFIG_STRING_STRING_TO_LOG_FOR, proc_name), XID_STRING_TO_LOG_LEN);

	}
	else {
		strcpy(s_xid_string_to_log, XID_DEFAULT_STRING_TO_LOG);
	}

	if (s_debug_level >= DEBUG_TRACE_LEVEL_LOW) {
		sprintf(s_msg_buff, "sf_check_and_set_intercept_xid: sp[%s], rset[%d], column[%d]",
		  	proc_name, s_intercept_xid_result_set, s_intercept_xid_column);
		sf_write_error_to_log(ALOG_INFO, 0, s_msg_buff);
	}
}

return;

} /* End of sf_check_and_set_intercept_xid() */




/*
 * Copy from the CIG-TRG code
 */

static int sf_get_strlen_without_padding_blanks(char *s, int len)
{
	int	i;

	if (s == NULL) {
		return (0);
	}
	if (len <= 0) {
		return (0);
	}	

	if (len > MAX_SYB_VALUE_SIZE) {
		len = MAX_SYB_VALUE_SIZE;
	}

	/*
	 * If the string is NOT padded with spaces, 
	 * then we do look into it!
	 */
	if (s[len - 1] != ' ') {
		return (len);
	}

	for (i = (len - 1); i >= 0; i--) {
		if (s[i] == '\0') {
			return (i);
		}
		if (s[i] != ' ') {
			return (i + 1);
		}
	}
	return (0);
		
} /* End of sf_get_strlen_without_padding_blanks() */




/*
 * Copy from the CIG-TRG code and adapted.
 * 
 * This function works with both params and columns. Therefore the
 * comments are ambiguous about whether the p_xdef is a param or a
 * columm.  It could be either.
 *
 * Return:
 *	< 0	if error
 *	> 0	nb of bytes used to store formatted value in buffer[]
 */

static int sf_format_cs_data_value(char *buffer, 
				   CT10_DATA_XDEF_T *p_xdef,
				   int	 is_last_xdef,
				   char *sep_string,
				   int	 int_width,
				   char	 string_quote_char,
				   int	 fix_var_string_limit,
				   int	 b_with_name)
{
	CS_DATAFMT	 date_to_string_fmt;				/* Require to convert date with cs_convert */
	CS_RETCODE	 cs_rc = 0;					/* Return code from cs_convert */
	CS_INT		 result_len = 0;				/* Result len from cs_convert */
	char		 string_quote_string[2] = "?";			/* ??? */
	char		 val_txt[MAX_SYB_VALUE_SIZE + 45] = "??x";	/* Work variable to receive result of convertion */

	if (s_debug_level >= DEBUG_TRACE_LEVEL_LOW) {

		sprintf(s_msg_buff, "sf_format_cs_data_value: maxlength[%ld], datatype[%ld], param name[%.20s]",
					p_xdef->fmt.maxlength,
					p_xdef->fmt.datatype,
					p_xdef->fmt.name );
		sf_write_error_to_log(ALOG_INFO, 0, s_msg_buff);
	}

	/*
	 * Check basic sanity of *p_xdef...
	 */
	if (p_xdef == NULL) {
		return (-10);
	}
	if (p_xdef->p_val == NULL) {
		return (-4);
	}
	if (p_xdef->fmt.maxlength > MAX_SYB_VALUE_SIZE) {
		return (-11);
	}

	/*
	 * Prepare formatting variables...
	 * Be very carefull string_quote_string is only 1 byte long.
	 */
	if (string_quote_char == '\0') {
		string_quote_string[0] = '\0';
	} else {
		string_quote_string[0] = string_quote_char;
	}

	/*
	 * Check if value was NULL:
	 *	char(n)	NULL
	 *	int	null
	 *	float	Null
	 *	real	nULL
	 */
	if (p_xdef->null_ind == -1) { 
		switch(p_xdef->fmt.datatype) {
		 case CS_CHAR_TYPE:
			strncpy(val_txt, RPC_CS_CHAR_NULL, 
				sizeof(val_txt) );
			break;
		 case CS_INT_TYPE:
			strncpy(val_txt, RPC_CS_INT_NULL, 
				sizeof(val_txt) );
			break;
		 case CS_SMALLINT_TYPE:
			strncpy(val_txt, RPC_CS_SMALLINT_NULL, 
				sizeof(val_txt) );
			break;
		 case CS_FLOAT_TYPE:
			strncpy(val_txt, RPC_CS_FLOAT_NULL, 
				sizeof(val_txt) );
			break;
		 case CS_REAL_TYPE:
			strncpy(val_txt, RPC_CS_REAL_NULL, 
				sizeof(val_txt) );
			break;
		 case CS_DATETIME_TYPE:
			strncpy(val_txt, RPC_CS_DATETIME_NULL, 
				sizeof(val_txt) );
			break;
		 case CS_DATETIME4_TYPE:
			strncpy(val_txt, RPC_CS_DATETIME4_NULL, 
				sizeof(val_txt) );
			break;
		 default:
			sprintf(val_txt, "\"NULL - Other Type=%d (len=%d)\"",
				p_xdef->fmt.datatype,
				p_xdef->len );
			break;
		} /* end switch(p_xdef->fmt.datatype) */
	} else {
		switch (p_xdef->fmt.datatype) {
		 case CS_CHAR_TYPE:
			/*
			 * Format as variable or fixed width string data?
			 */
			if (p_xdef->fmt.maxlength > fix_var_string_limit) {
				sprintf(val_txt, "%.2s%.*s%.2s",
					string_quote_string,
					sf_get_strlen_without_padding_blanks(
						(char *) p_xdef->p_val,
						p_xdef->len),
					(char *) p_xdef->p_val,
					string_quote_string);
			} else {
				sprintf(val_txt, "%.2s%-*.*s%.2s",
					string_quote_string,
					p_xdef->fmt.maxlength,
					p_xdef->fmt.maxlength,
					(char *) p_xdef->p_val,
					string_quote_string);
			}
			break;

		 case CS_INT_TYPE:
		 case CS_SMALLINT_TYPE:
			if (int_width > 0) {
				sprintf(val_txt, "%*d", 
					int_width,
					(p_xdef->fmt.datatype == CS_INT_TYPE)
					  ? *((CS_INT *) p_xdef->p_val)
					  : *((CS_SMALLINT *) p_xdef->p_val) );
			} else {
				sprintf(val_txt, "%d", 
					(p_xdef->fmt.datatype == CS_INT_TYPE)
					  ? *((CS_INT *) p_xdef->p_val)
					  : *((CS_SMALLINT *) p_xdef->p_val) );
			}
			break;

		 case CS_FLOAT_TYPE:
			sprintf(val_txt, "%f", 
				(double) *((CS_FLOAT *) p_xdef->p_val));
			break;

		 case CS_REAL_TYPE:
			sprintf(val_txt, "%f", 
				(double) *((CS_REAL *) p_xdef->p_val));
			break;

		 case CS_DATETIME_TYPE:
		 case CS_DATETIME4_TYPE:
			memset((void *) &date_to_string_fmt, 0,
				  (CS_INT) sizeof(date_to_string_fmt) ); 

			date_to_string_fmt.datatype  = CS_CHAR_TYPE;
			date_to_string_fmt.maxlength = sizeof(val_txt);
			date_to_string_fmt.format    = CS_FMT_NULLTERM;

			/* Target of cs_convert() is val_txt[] buffer
			 * at position [1].
			 * val_txt[0] will receive a '"' delimiter.
			 * val_txt[result_len + 1] will become "\""
			 */

			val_txt[0] = '"';
			cs_rc = cs_convert(ct10api_get_context(),
					  &(p_xdef->fmt),
					  (CS_VOID *) p_xdef->p_val,
					  &date_to_string_fmt,
					  (CS_VOID *) &val_txt[1],
					  &result_len);
			if (cs_rc != CS_SUCCEED) {
				sprintf(val_txt, 
				 "\"Convert of CS_DATETIME Failed!!! (p=%p)\"",
				 (char *) p_xdef->p_val );
			} else {
				if ((result_len + 3) >= sizeof(val_txt) ) {
					result_len = (sizeof(val_txt) - 3);
				}
				/* result_len includes the terminating NUL 
				 * byte. And there is one quote already at
				 * [0]. So, we copy over starting at
				 * val_txt[result_len]:
				 */
				strcpy(&val_txt[result_len], "\"");
			}
			break;

 		 default:
			sprintf(val_txt, "\"p=%p Other Type=%d (len=%d)\"",
				(char *) p_xdef->p_val,
				p_xdef->fmt.datatype,
				p_xdef->len );
			break;
		} /* end switch(p_xdef->fmt.datatype) */
	} /* endif value is NULL */


	/*
	 * Format data value into buffer[], with or without its name
	 * depending if it is named or not.
	 *
	 * A separator (sep_string) is appended to the value string if the 
	 * data value is not the last one.
 	 * 
	 * fmt.namelen = -9 if null terminated. I hope that = 0 when not 
	 * available.
	 */
	if (b_with_name
	 && p_xdef->fmt.namelen != 0) {

		sprintf(buffer, "%.*s = %.*s%.3s", 
				p_xdef->fmt.namelen,
				p_xdef->fmt.name,
				MAX_SYB_VALUE_SIZE + 4,
				val_txt,
				(is_last_xdef) ? "" : sep_string );

	} else {
		sprintf(buffer, "%.*s%.3s", 
				MAX_SYB_VALUE_SIZE + 4,
				val_txt,
				(is_last_xdef) ? "" : sep_string );
	}

	return ( strlen(buffer) );

} /* End of sf_format_cs_data_value() */




/*
 * Adapt from CIG-TRG code
 *
 * Simple wrapper to init some default values
 */

static int sf_format_param_value(char *buffer, 
				CT10_DATA_XDEF_T *p_param,
				int  is_last_param)
{
 return (sf_format_cs_data_value(buffer, 
				 p_param,
				 is_last_param,
				 ", ",		/* sep_string		*/
				 0,		/* int print width	*/
				 '"',		/* string_quote_char	*/
				 0,		/* fix_var_string_limit	*/
				 TRUE)		/* with the name	*/
	);

} /* End of sf_format_param_value() */




/*
 * Adapt from CIG-TRG code
 *
 * Formats the values of each param of tab_params[] in a string
 * 
 * **** Return code must be rework ****
 */

static int sf_format_all_params_values(	void *tab_params[],
					int  nb_params, 
					char *buffer,
					int  buffer_size)
{
	int     	  	rc            = 0, 
			  	i             = 0,     /* subscript of p_tab_params[] */
			  	new_len       = 0,
			  	nb_bytes_used = 0;

	CT10_DATA_XDEF_T	**p_param	= NULL;

	p_param = (CT10_DATA_XDEF_T**) tab_params;
	

	
	if (s_debug_level >= DEBUG_TRACE_LEVEL_LOW) {

		sprintf(s_msg_buff, "sf_format_all_params_values: nb_params[%d]", nb_params);
		sf_write_error_to_log(ALOG_INFO, 0, s_msg_buff);
	}


	for (i = 0, nb_bytes_used = 0;
	    i < nb_params  &&  i < MAX_SYB_NB_PARAMS;
	    i++) {

		if (s_debug_level >= DEBUG_TRACE_LEVEL_LOW) {

			sprintf(s_msg_buff, "sf_format_all_params_values: i[%d], nb_bytes_used[%d]", i, nb_bytes_used);
			sf_write_error_to_log(ALOG_INFO, 0, s_msg_buff);
		}


		if ((p_param[i])->p_val == NULL) {
			break;
		}
		if ((nb_bytes_used + MAX_SYB_VALUE_SIZE)
		    > buffer_size) {
			return (-1);
		}


		new_len = sf_format_param_value(&(buffer[nb_bytes_used]), 
						p_param[i],
						( (i + 1) >= nb_params) );

		if (new_len < 0) {
			return (new_len);
		}
		nb_bytes_used = (nb_bytes_used + new_len);

	} /* for each param */

	if (nb_bytes_used < buffer_size ) {
		buffer[nb_bytes_used] = '\0';	/* terminate string */
		nb_bytes_used++;		/* count NUL byte */
	} else {
		return (-2);
	}
	
	return (0);

} /* End of sf_format_all_params_values() */




/*
 * Adapt from the CIG-TRG code
 * rpc_audit log format must be compatible with TRG format.
 *
 * **** Many rpc entry are default to Zero. Should be clean. ****
 */

static int  sf_write_rpc_audit_log_entry(char	*rpc_name,
					void	*tab_params,
                                        int	nb_params,
                                        char	*log_buffer,
                                        int	buffer_size,
					int	buffer_posi
) {
	int rc;
	char work_buffer[MAX_RPC_AUDIT_WORK_BUFFER_SIZE + 1];
	char    time_string[80] = "[time?]";

	if (( rc = sf_format_all_params_values (
				tab_params,
				nb_params,
				work_buffer,
				MAX_RPC_AUDIT_WORK_BUFFER_SIZE) ) != 0) {

		sprintf(s_msg_buff, "sf_write_rpc_audit_log_entry: error formatting rpc_audit params");
		sf_write_error_to_log(ALOG_ERROR, 0, s_msg_buff);

		return (1);
	} 

 /* Format the string to be logged in the RPC Audit Log: */

	sf_format_usec_time(time_string, sizeof(time_string), st_tval_end_rpc.tv_sec, st_tval_end_rpc.tv_usec);

        sprintf(&(log_buffer[buffer_posi]),
                ("%s%s : %.*s%s%.32s%s; %.*s; %.*s; ret=%d; xid=%d; %.*s (%.*s); "
                 "rc_mask=%x; rows=%ld; rc=%d; step=%d; msg='%.200s'"),
		RPC_LINE_PREFIX,
		time_string,
                sizeof(s_user_name), s_user_name,	/* User name */

                (NULL != NULL) ? " \"" : "", 		/* Audit login ID optional */
                (NULL != NULL) ? "audtlogid" : "",
                (NULL != NULL) ? "\"" : "",

                sizeof(s_trg_name), s_trg_name,		/* TRG name */
                2, "XX", 				/* Destination name dont exist in xml2syb ??? */
                s_rpc_return_status,         		/* Stored proc return status */
                0,					/* xid ??? */
                30,					/* Size of proc name */
                rpc_name,               		/* Name of stored procedure  */
                MAX_RPC_AUDIT_WORK_BUFFER_SIZE,		/* List of params buffer size */
                work_buffer, 	         		/* List of parameters */
                0,       	         		/* rc_mask ??? */
                s_rpc_nb_rows,                		/* Total rpc nb of rows */
                0,					/* rc from ct10api   */
		0,					/* step ??? */
                "");					/* status message ??? */


	if ((rc = sf_write_to_rpc_audit( log_buffer) ) != 0) {

		sprintf(s_msg_buff, "sf_write_rpc_audit_log_entry: error writing rpc_audit log ");
		sf_write_error_to_log(ALOG_ERROR, 0, s_msg_buff);
		return (2);
	}
 
        return (0);

} /* End of sf_write_rpc_audit_log_entry() */




/*
 * Not use 

static char *sf_get_name_of_log()
{
	char	*p_name_of_log = NULL;

	p_name_of_log = ucfg_get_param_string_first(PAR_LOG_FILENAME);

	if (p_name_of_log == NULL) {
		return (DEF_LOG_FILENAME);
	}
	return (p_name_of_log);

}  End of sf_get_name_of_log() */




/*
 * Not use 

static char *sf_get_appl_name()
{
	char	*p_val = NULL;

	p_val = ucfg_get_param_string_first(PAR_CLT_APPL_NAME);
	if (p_val == NULL) {
		return (DEF_APPL_NAME);
	}
	return (p_val);

}  End of sf_get_appl_name() */




/*
 * Not use 
 * We may have to log hostname.
 */

static char *sf_get_hostname()
{
 static char	hostname_buff[80] = "[hostname?]";

	if (gethostname(hostname_buff, sizeof(hostname_buff)) == 0) {
		return (hostname_buff);
	}
	return ("[gethostname() failed]");

} /* End of sf_get_hostname() */




/*
 * This function accumulate message from a callback from ct10reco 
 * while the SP is execute. At the end of the SP execution, these
 * messages will be added to the XML output stream. The MAX_NB_MESSAGESth message
 * is reserve. The systeme will create a special message indicating
 * the number of missing messages. The limit MAX_NB_MESSAGES must
 * be high enought that we never miss any message.
 * 
 * Return code:
 *	0: Message save, will be return in the XML output stream 
 *	1: To many messages, wont be return in the XML ouput stream
 */

static int sf_save_error_msg(int msg_num, char *msg_text, int msg_text_len)
{

	++s_nb_msg;

	if (s_nb_msg >= MAX_NB_MESSAGES) {
		return 1;
	}

	if (msg_text_len > MSG_TEXT_SIZE) {
		msg_text_len = MSG_TEXT_SIZE;
	}

	strncpy(s_msg_tab[s_nb_msg].msg_text, msg_text, msg_text_len);
	s_msg_tab[s_nb_msg].msg_text[msg_text_len] = '\0';
	
	s_msg_tab[s_nb_msg].msg_num = msg_num;

	return 0;

} /* End of sf_save_error_msg() */




/*
 * Before a new SP these variables must be reset.
 */

static void sf_reset_static_values()
{

	sf_save_start_time();
	s_nb_msg = 0;
	s_rpc_nb_rows = 1;		/* We start with 1 for the return status */
	s_rpc_return_status = -999;
	rpc_audit_buffer_posi = 0;

	s_intercept_xid = FALSE;
	s_intercept_xid_result_set = 0;
	s_intercept_xid_column = 0;

} /* End of sf_reset_static_values() */




/* 
 * Build last message that indicate that the
 * message limit is reach.
 */

void sf_build_missing_message_string(int s_nb_msg)
{
	char buff[25];

	sprintf(buff, "%d", s_nb_msg+1 - MAX_NB_MESSAGES);
	strcpy(s_msg_tab[MAX_NB_MESSAGES].msg_text, MISSING_MSG_STRING_1);
	strcat(s_msg_tab[MAX_NB_MESSAGES].msg_text, buff);
	strcat(s_msg_tab[MAX_NB_MESSAGES].msg_text, MISSING_MSG_STRING_2);
	s_msg_tab[MAX_NB_MESSAGES].msg_num = 0;

} /* End of sf_build_missing_message_string() */




/* 
 * Write the list of error messages to the XML
 * output stream.
 */

static void sf_write_error_msg()
{
	int i;
	void		*p_ctx	= NULL;

	if ( s_nb_msg == 0 ) {
		return;
	}

	if ( s_nb_msg >= MAX_NB_MESSAGES ) {
		sf_build_missing_message_string(s_nb_msg);
		s_nb_msg = MAX_NB_MESSAGES;
	}

	p_ctx = (void*) xmltp_lex_get_single_thread_context();

	xmltp_writer_begin_msg(p_ctx, s_last_result_set_nb_rows);

	for (i=1; i<= s_nb_msg; i++) {

		xmltp_writer_msg(p_ctx, s_msg_tab[i].msg_num, s_msg_tab[i].msg_text);

	}

	xmltp_writer_end_msg(p_ctx);

	return;

} /* End of sf_write_error_msg() */




/*
 * Convert CTlib to JDBC datatype.
 */

static int sf_convert_to_jdbc_datatype(int datatype)
/*
 * Called by:	sf_process_row()
 */
{
	switch ( datatype ) {
	case CS_TINYINT_TYPE:
	case CS_SMALLINT_TYPE:
			return (JAVA_SQL_INTEGER);

	case CS_INT_TYPE:
			return (JAVA_SQL_INTEGER);

	case CS_DATETIME_TYPE:
			return (JAVA_SQL_TIMESTAMP);

	case CS_VARCHAR_TYPE:
			return (JAVA_SQL_VARCHAR);

	case CS_CHAR_TYPE:
			return (JAVA_SQL_VARCHAR);

	case CS_FLOAT_TYPE:
			return (JAVA_SQL_FLOAT);

	case CS_NUMERIC_TYPE:
			return (JAVA_SQL_INTEGER);
	default:
			break;
	}
	return (JAVA_SQL_VARCHAR);

} /* End of sf_convert_to_jdbc_datatype() */




/*
 * CTlib rows callback.
 */

static int sf_process_row(	void	 	 *p_ct10_conn, 
				int 		  b_is_row,
				CT10_DATA_XDEF_T *data_array[],
				int		  nb_data,
				int		  result_set_no,
				CS_RETCODE	  result_type,
				int		  header_ind)
/*
 * Called by:	by reference -- this is callback function!
 *		It is called once for each row of a result set
 *		or the set of output parameters
 *		coming from the execution of a RPC.
 *
 * Return:
 *	CT10_SUCCESS	Always.
 */
{
#define CONV_BUFF_SIZE		1024

	void		*p_ctx	= NULL;
	int		 i	= 0;
	CS_INT		 outl	= 0,
			 rc	= 0;
	CS_DATAFMT 	 fmt_out,	/* will be initialized below */
			 fmt_in;
	char		 cnv_buff[CONV_BUFF_SIZE] = "[cnv_buff?]";


	/* Get the context (socket) to which we send the XML results.
	 */
	p_ctx = (void*) xmltp_lex_get_single_thread_context();

	sf_save_end_time();
	if (sf_delta_tval_in_ms(&st_tval_begin_rpc, &st_tval_end_rpc) >= (s_exec_timeout*1000) ) {

		sprintf(s_msg_buff,"sf_process_row: Stored procedure as timed out while processing results"); 
		sf_write_error_to_log(ALOG_ERROR, 0, s_msg_buff);

		s_timeout_ind = 1;

		rc = ct10api_cancel_con(p_ct10_conn);
		return CT10_SUCCESS;
	}


	/* This function here is called for various kinds of results:
	 * columns headers, rows, output parameters, their headers (names),
	 * and, the count of nb of rows.
	 */
	if (header_ind == CT10API_HEADER_IND_NB_ROW) {
		/*
		 * if (result_set_no != -1)
		 * then
		 *	result_set_no is the nb of rows in the previous result set.
		 *
		 */

		if (result_set_no != -1) {
			s_last_result_set_nb_rows = result_set_no;
			s_rpc_nb_rows += result_set_no;
		}

		return CT10_SUCCESS;
	}

	/*
	 * We use cs_convert() to convert all datatypes to string.
	 * The XML tags will be added after this first conversion.
	 *
	 * NOTE: if an explicit character set conversion is required
	 *	 from the native charset to "ISO-8859-1", it is probably
	 *	 here that it should be done.
	 *
	 * Here, below, we prepare a CS_DATAFMT, fmt_out, that specifies
	 * the target format that we want to have:
	 */
	memset(&fmt_out, 0, sizeof(fmt_out) );
	fmt_out.datatype  = CS_CHAR_TYPE;
	fmt_out.maxlength = sizeof(cnv_buff);	/* cs_convert() use cnv_buff[] */
	fmt_out.locale = NULL;
	fmt_out.format = CS_FMT_NULLTERM;

	if (header_ind == CT10API_HEADER_IND_TRUE) {

		if (result_type == CS_PARAM_RESULT) {

			xmltp_writer_begin_output_params(p_ctx, result_set_no, s_last_result_set_nb_rows);

			for (i=0; i < nb_data; ++i) {

				xmltp_writer_param_name(p_ctx,
					(data_array[i])->fmt.name,
					sf_convert_to_jdbc_datatype(
						(data_array[i])->fmt.datatype)
					);
			}
			return (CT10_SUCCESS);
		}

		xmltp_writer_begin_result_set(p_ctx, result_set_no, s_last_result_set_nb_rows);

		for (i=0; i < nb_data; ++i) {

			xmltp_writer_column_name(p_ctx,
				(data_array[i])->fmt.name,
				sf_convert_to_jdbc_datatype(
					(data_array[i])->fmt.datatype),
				(data_array[i])->fmt.maxlength
				);
		}
		return (CT10_SUCCESS);
	}

	/* Otherwise, if we come here,
	 * it must be (header_ind == CT10API_HEADER_IND_FALSE)...
	 */
	for (i=0; i<nb_data; ++i) {

		/* If not null convert data to string:
		 */
		if ((data_array[i])->null_ind == 0) {
			/*
			 * Use a copy of the original fmt, do not touch original:
			 */
			memcpy(&fmt_in, &((data_array[i])->fmt),
					sizeof(CS_DATAFMT));
			/*
			 * Ajust actual datalen to be converted.
			 */
			fmt_in.maxlength = (data_array[i])->len;
	
			/* Convert data to string:
			 */

			if (fmt_in.datatype != CS_DATETIME_TYPE) {
				rc = cs_convert( ct10api_get_context(),
						&fmt_in, 
					 	(data_array[i])->p_val,
				    		&fmt_out,
					 	cnv_buff,
						&outl);

				if (rc != CS_SUCCEED) {
					sprintf(cnv_buff,
						"cs_convert() error, rc=%d, i=%d, typ=%d",
						rc, i,
						(data_array[i])->fmt.datatype );
	
					sf_write_log_msg_mm(ALOG_ERROR, result_set_no,
						"ERROR in sf_process_row():",
						cnv_buff);
	
					xmltp_writer_note_error(p_ctx, cnv_buff);
				
					return (CT10_ERR_FATAL_ERROR);
				}
			}
			else {
				rc = ct10api_convert_date_to_string_std((data_array[i])->p_val, cnv_buff);	
			}

		} else {
			strcpy(cnv_buff, "NULL");
		}

		if (result_type == CS_PARAM_RESULT) {

			xmltp_writer_param_value(p_ctx,
					(data_array[i])->fmt.name,
					sf_convert_to_jdbc_datatype(
						(data_array[i])->fmt.datatype),
					(data_array[i])->fmt.maxlength,
					1,	/* is_output */
					((data_array[i])->null_ind != 0),
					cnv_buff
					);
		} else {

			/***** XID ******/

			if ( 	(s_intercept_xid == TRUE) &&
				(s_intercept_xid_result_set == result_set_no) &&
				(s_intercept_xid_column == i) ) {

					sf_log_xid(cnv_buff);

			} 

			xmltp_writer_column_value(p_ctx,
					sf_convert_to_jdbc_datatype(
						(data_array[i])->fmt.datatype),
					((data_array[i])->null_ind != 0),
					cnv_buff
					);
		}
	} /* end for() */

	if (result_type == CS_PARAM_RESULT) {
		xmltp_writer_end_param_values(p_ctx);
	} else {
		xmltp_writer_end_colum_values(p_ctx);
	}

	return (CT10_SUCCESS);

} /* End of sf_process_row() */




/*
 * We need to make sure that all the playback assign sequence are just
 * before the corresponding strored proc in the rpc_audit.log file.
 * In order to do that we accumulate in a buffer all the related rpc_audit entries
 * and we will write everything in one single write operation.
 *
 * I HOPE THIS WILL WORK EVENT IF MANY PROCESS TRY TO WRITE IN THE LOG AT THE
 * SAME TIME. If it's not good enought we will have to lock the file before
 * writing.
 */

void sf_save_playback_assign_seq(char *msg_text, 
				int msg_text_len,
				char *log_buffer,
				int log_buffer_size,
				int *buffer_posi)
{
	char    time_string[80] = "[time?]";

	sf_format_usec_time(time_string, sizeof(time_string), st_tval_begin_rpc.tv_sec, st_tval_begin_rpc.tv_usec);

        sprintf(&(log_buffer[*buffer_posi]),
                ("%s%s : %.*s%s%.32s%s; %.*s; %.*s; ret=%d; xid=%d; %s%.*s; "
                 "rc_mask=%x; rows=%ld; rc=%d; step=%d; msg='%.200s'\n"),

		RPC_LINE_PREFIX,
		time_string,

                sizeof(s_user_name), s_user_name,				/* User name */

                (NULL != NULL) ? " \"" : "", 					/* Audit login ID optional */
                (NULL != NULL) ? "audtlogid" : "",
                (NULL != NULL) ? "\"" : "",

                sizeof(s_trg_name), s_trg_name,					/* TRG name */
                2, "XX", 							/* Destination name dont exist in xml2syb ??? */
                0,     			    					/* Stored proc return status */
                0,								/* xid ??? */
		RPC_PLAYBACK_SP_PREFIX,
                msg_text_len - sizeof(PLAYBACK_ASSIGN_SEQ_INTERCEPT_STRING),	/* List of params buffer size */
                &(msg_text[sizeof(PLAYBACK_ASSIGN_SEQ_INTERCEPT_STRING)-1]),	/* List of parameters */
                0,       	         					/* rc_mask ??? */
                0,	                					/* Total rpc nb of rows */
                0,								/* rc from ct10api   */
		0,								/* step ??? */
                "");								/* status message ??? */

		*buffer_posi += strlen(&(log_buffer[*buffer_posi]));

} /* End of sf_save_playback_assign_seq() */




/*
 * CTlib message call back
 */

static int sf_handle_error_msg(int	 b_to_log,
				char 	*p_app_context_info,
				int	 msg_no,
				int	 severity,
				int	 layer,
				int	 origin,
				int	 msg_text_len,
				char	*msg_text,
				int	 srv_name_len,	
				char	*srv_name,
				int	 proc_name_len,
				char	*proc_name,
				int	 os_msg_len,
				char	*os_msg,
				int	 proc_line_or_os_number,
				char	*error_category_name )
/*
 * Called by:	sf_init_cfg_log_ct10api()	-- address is assigned to funct ptr
 *					-- held within ct10reco.c
 *
 * Display CT-Lib and Remote error messages on stderr.
 *
 * Return 0.
 */
{
 char	msg_buff[CS_MAX_MSG + CS_MAX_MSG + 500] = "logmsg!?";
 int	rc;

 /*
  * Check if msg_no is one of the values of param ERRORS_TO_IGNORE,
  * if so, ignore it:
  */
 sprintf(msg_buff, "%d", msg_no);

 if (ucfg_is_string_in_param_values_list(PAR_ERRORS_TO_IGNORE, msg_buff) ) {
 	return (0);
 }

 if (strncmp(msg_text, PLAYBACK_ASSIGN_SEQ_INTERCEPT_STRING,
	sizeof(PLAYBACK_ASSIGN_SEQ_INTERCEPT_STRING)-1) == 0) {

	sf_save_playback_assign_seq(	msg_text, 
					msg_text_len,
					rpc_audit_log_buffer,
					MAX_RPC_AUDIT_LOG_BUFFER_SIZE,
					&rpc_audit_buffer_posi);

} 
else {

 rc = sf_save_error_msg(msg_no, msg_text, msg_text_len);

 sprintf(msg_buff,
 	("%.20s: %.*s%.10smsg %d, sev %d: "
	 "'%.*s' "
	 "%.10s%.*s"
	 "%.10s%.*s (%d) "
	 "[%.30s]"),
	(s_current_active_conn != NULL)
		? ct10api_get_server_name_of_conn(s_current_active_conn)
		: "[No active conn?]",
	srv_name_len,	
	srv_name,
	(srv_name_len > 0) ? ": " : "",
	msg_no,
	severity,
	msg_text_len,
	msg_text,
	(proc_name_len > 0) ? "proc=" : "",
	proc_name_len,
	proc_name,
	(os_msg_len > 0) ? ", " : "",
	os_msg_len,
	os_msg,
	proc_line_or_os_number,
	error_category_name );

 sf_write_error_to_log(errutl_severity_to_alog_err_level(severity),
 		       msg_no,
 		       msg_buff);

}

return (0);

} /* End of sf_handle_error_msg() */




/*
 * A few think not done in ct10init
 */

static int sf_init_cfg_log_ct10api()
/*
 * Called by:	main()
 *
 * RETURN:
 *	0	OK
 *	< 0	Failed
 */
{
	int	 rc = 0,
		 i = 0;
	char	*p_name_of_log = NULL,
		*p_appl_name = NULL,
		*p_val = NULL;

	/*
	 * Minimize not so important "error" messages written to standard
	 * application log by ct10api.c :
	 */
#if 0 /* NOT quiet @@@ */
	ct10api_set_log_mode_quiet(1);		/* TRUE ---> quiet */
#endif

	/*
	 * Direct callback errors messages to stderr:
	 */
	ct10reco_assign_pf_display_err_msg(sf_handle_error_msg);


	/*
	 * Which version of CT10 Api are we using?
	 */

	if (s_debug_level >= DEBUG_TRACE_LEVEL_LOW) {
		printf("\nversion: %.80s\n", VERSION_ID);
		printf("ct10api version: %.80s\n\n", ct10api_get_version());
		fflush(stdout);
	}

	/*
	 * Assign debug level and Application Name for ct10api.c:
	 */
	ct10api_assign_debug_trace_flag(s_debug_level);

	ct10api_assign_application_name(APPNAME_IN_LOG_FILE);

	return (0);

} /* end of sf_init_cfg_log_ct10api() */





static int sf_get_param_num_value_w_default(char *param, int def_value)
/*
 * Called by:	sf_init_master_socket_listen()
 *
 * Return:
 *	int	the value of the param
 *	int	the default value if param is not in the config
 */
{
	char	*p_val = NULL;

	p_val = ucfg_get_param_string_first(param);
	if (NULL == p_val) {
		return (def_value);
	}
	return (atoi(p_val) );

} /* End of sf_get_param_num_value_w_default() */





static int sf_init_master_socket_listen()
/*
 * Called by:	main()
 *
 * Do bind() and listen() for the "master" socket (only in the
 * parent process, not in the children).
 *
 * Return:
 *	>=0	a valid listen_socket
 *	-1	retry limit exhausted to try bind and listen
 *	-2	config file param missing
 */
{
	int	 listen_socket 	= -1;
	int	 sleep_retry	= 0,
		 nb_retry_listen = 0,
		 queue_lenth	= 0;
	char	 msg[300] = "[msg?]";

	/* Get the parameters values:
	 */
	sleep_retry     = sf_get_param_num_value_w_default(SOCKPARA_SLEEP_RETRY_BIND,
						SOCKPARA_SLEEP_RETRY_BIND_DEFAULT );

	nb_retry_listen = sf_get_param_num_value_w_default(SOCKPARA_NB_RETRY_LISTEN,
						SOCKPARA_NB_RETRY_LISTEN_DEFAULT );

	queue_lenth     = sf_get_param_num_value_w_default(SOCKPARA_QLEN,
						SOCKPARA_QLEN_DEFAULT );

	if (NULL == s_listen_port) {
		sf_write_log_msg_mm(ALOG_ERROR, 0, "Parameter missing:",
						SOCKPARA_LISTEN_PORT ); 
		return (-2);
	}

	/* Write the parameters values in the log (to help troubleshooting):
	 */
	sprintf(msg, "%.30s=%d, %.30s=%d, %.30s=%d, %.30s=%.30s",
		SOCKPARA_SLEEP_RETRY_BIND,	sleep_retry,
		SOCKPARA_NB_RETRY_LISTEN,	nb_retry_listen,
		SOCKPARA_QLEN,			queue_lenth,
		SOCKPARA_LISTEN_PORT, 		s_listen_port  );

	sf_write_log_msg_mm(ALOG_INFO, 0, "service socket parameters:", msg);

	
	while ( nb_retry_listen > 0 ) {

		listen_socket =	sock_socket_bind_and_listen_ext(ANY_HOST_ADDRESS,
							    s_listen_port,
							    queue_lenth, 1 );
		if ( listen_socket >= 0 ){
			return (listen_socket);
		}
		sf_write_log_msg_mm(ALOG_INFO, 0,
				"Failed, sock_socket_bind_and_listen_ext():",
				sock_get_last_error_diag_msg() );
		sleep( sleep_retry );

		nb_retry_listen--;
	}

	sf_write_log_msg_mm(ALOG_ERROR, 0,
		"ERROR: bind/listen() failed too many times in sf_init_master_socket_listen():",
		sock_get_last_error_diag_msg() );

	return( -1 );

} /* End of sf_init_master_socket_listen() */




/* -------------------------------------- Functions to process RPC: */	




static char *sf_describe_diag_mask(long diag_mask)
{
 static char	desc_buff[20] = "desc?!";
 
	if (diag_mask & CT10_DIAG_NO_SUCH_SERVER) {
		return ("NO_SUCH_SERVER");
	}
	if (diag_mask & CT10_DIAG_CANNOT_FIND_HOST) {
		return ("CANNOT_FIND_HOST");
	}
	if (diag_mask & CT10_DIAG_LOGIN_REJECTED) {
		return ("LOGIN_REJECTED");
	}
	if (diag_mask & CT10_DIAG_CONNECT_TIMEOUT) {
		return ("CONNECT_TIMEOUT");
	}
	if (diag_mask & CT10_DIAG_DISCONNECTED_BY_PEER) {
		return ("DISCONNECTED_BY_PEER");
	}
	if (diag_mask & CT10_DIAG_TIMEOUT) {
		return ("TIMEOUT");
	}
	sprintf(desc_buff, "%lx", diag_mask);

	return (desc_buff);

} /* End of sf_describe_diag_mask() */



static char *sf_get_problem_category(long diag_mask)
{
	if (diag_mask 
	  & (CT10_DIAG_NO_SUCH_SERVER | CT10_DIAG_LOGIN_REJECTED) ) {
		return ("BAD CONFIG");
	}

	if (diag_mask
	 &  (CT10_DIAG_CANNOT_FIND_HOST | CT10_DIAG_CONNECT_TIMEOUT) ) {
		return ("CONNECT FAILED, SERVER DOWN");
	}

	if (diag_mask & CT10_DIAG_DISCONNECTED_BY_PEER) {
		return ("CONNECTION BROKEN");
	}

	if (diag_mask & CT10_DIAG_TIMEOUT) {
		return ("SERVER HUNG OR VERY SLOW");
	}

	return ("UNKNOWN PROBLEM");

} /* end of sf_get_problem_category() */





static void sf_diag_rpc_exec_error(CS_INT ret_stat, int rc, char *rpc_string,
				   void *p_conn)
/*
 * Called by:	sf_exec_rpc()
 */
{
	char	 msg_buff[CS_MAX_MSG + 500] = "exec err msg?!";	

	sprintf(msg_buff, 
		"%.50s: %.30s %.40s rc=%d, diag=%lx, status=%d.",
		sf_get_problem_category(ct10api_get_diagnostic_mask(p_conn) ),
		(ct10api_get_server_name_of_conn(p_conn) != NULL) 
		  ? ct10api_get_server_name_of_conn(p_conn)
		  : "[No active conn?]",
		sf_describe_diag_mask(ct10api_get_diagnostic_mask(p_conn) ),
		rc,
		ct10api_get_diagnostic_mask(p_conn),
		ret_stat
		);

	sf_write_error_to_log(ALOG_ERROR, rc, msg_buff);

} /* end of sf_diag_rpc_exec_error() */





static int sf_check_ct10_data_xdef_is_valid(void *p_param, char *calling_fn_name)
/*
 * Called by:	xml2db_get_name_of_param()
 *		xml2db_free_param_struct()
 *
 * Check the validity of certain fields within the struct (if not NULL pointer).
 *
 * if (calling_fn_name != NULL), write an error msg in the log.
 *
 * Return:
 *	0	p_param was a valid parameter structure (probably)
 *	-1	p_param was NULL
 *	-2	p_param was not a valid struct (detection not guaranteed)
 */
{
	CT10_DATA_XDEF_T	*p = NULL;

	if (NULL == p_param) {
		return (-1);
	}
	p = (CT10_DATA_XDEF_T *) p_param;

	/* Check if this is a valid CT10_DATA_XDEF_T structure:
	 */
	switch (p->fmt.datatype) {
	case CS_DATETIME_TYPE:
	case CS_FLOAT_TYPE:
	case CS_INT_TYPE:
	case CS_CHAR_TYPE:
		break;		/* OK, a known datatype! */
	default:
		if (calling_fn_name != NULL) {
			sf_write_log_msg_mm(ALOG_ERROR, p->fmt.datatype,
				calling_fn_name,
				"Not a good fmt.datatype, param struct not valid");
		}
		return (-2);
	}
	switch (p->fmt.status) {
	case CS_INPUTVALUE:
	case CS_RETURN:
		break;		/* OK, a goof fmt.status */
	default:
		if (calling_fn_name != NULL) {
			sf_write_log_msg_mm(ALOG_ERROR, p->fmt.status,
				calling_fn_name,
				"Not a good fmt.datatype, param struct not valid");
		}
		return (-2);
	}
	return (0);

} /* end of sf_check_ct10_data_xdef_is_valid() */





/* -------------------------------- PUBLIC xml2db_ API functions: */

static	int	s_abort_flag	= 0,
		s_abort_rc	= 0;
static	char	s_abort_reason1[300] = "[no reason yet]",
		s_abort_reason2[300] = "[no reason2]";




void xml2db_abort_program(int rc, char *msg1, char *msg2)
/*
 * Used by the parser to tell the main program that too many
 * parse errors have occurred, that the XML-TP protocol is not
 * followed, and, that it should drop the connection and abort.
 *
 * The explanations about the error conditions are in the strings
 * msg1, and, msg2.
 */
{
	int error_level = 0;

	s_abort_flag++;
	s_abort_rc = rc;
	if (NULL == msg1) {
		msg1 = "";
	}
	if (NULL == msg2) {
		msg2 = "";
	}
	strncpy(s_abort_reason1, msg1, (sizeof(s_abort_reason1) - 1) );
	strncpy(s_abort_reason2, msg2, (sizeof(s_abort_reason2) - 1) );

	if ( (rc < -1) || (rc >= 0) ) {
		error_level = ALOG_WARN;
	}
	else {
		error_level = ALOG_INFO;
	}

	/* Do NOT write log if msg2[0] == '0', unless debug level is 0 :
	 */
	if (msg2 != NULL && msg2[0] == '0' && s_debug_level < 3) {
		return;
	}
	sf_write_log_msg_mm(error_level, rc, msg1, msg2);

} /* end of xml2db_abort_program() */





void xml2db_write_log_msg_mm(int errlvl, int rc, char *msg1, char *msg2)
{
	sf_write_log_msg_mm(errlvl, rc, msg1, msg2);

} /* end of xml2db_write_log_msg_mm() */





int xml2db_jdbc_datatype_id_to_native(int jdbc_type_id)
{
 static int	already_said = 0;	/* only write log once about invalid type */
	char	errstr[80] = "[other?]";
 
	switch (jdbc_type_id) {
	case JAVA_SQL_VARCHAR:
	case JAVA_SQL_CHAR:
		return (CS_CHAR_TYPE);

	case JAVA_SQL_DATE:
	case JAVA_SQL_TIME:
	case JAVA_SQL_TIMESTAMP:
		return (CS_DATETIME_TYPE);

	case JAVA_SQL_INTEGER:
		return (CS_INT_TYPE);

	case JAVA_SQL_DOUBLE:
	case JAVA_SQL_FLOAT:
		return (CS_FLOAT_TYPE);

	/* All those which follow are not supported at this moment.
	 * Normally, they are not generated by the Java framework.
	 * See classes: com.cjc.common.sql.lowLevel.SQLValue
	 *		com.cjc.common.sql.lowLevel.SQLParam
	 * (2001sept05,jft)
	 */
	case JAVA_SQL_BIGINT:
	case JAVA_SQL_BINARY:
	case JAVA_SQL_BIT:
	case JAVA_SQL_DECIMAL:
	case JAVA_SQL_LONGVARBINARY:
	case JAVA_SQL_LONGVARCHAR:
	case JAVA_SQL_NULL:
	case JAVA_SQL_NUMERIC:
	case JAVA_SQL_OTHER:
	case JAVA_SQL_REAL:
	case JAVA_SQL_SMALLINT:
	case JAVA_SQL_TINYINT:
	case JAVA_SQL_VARBINARY:
	default:
		break;
	}
	if (!already_said) {
		already_said++;
		sprintf(errstr, "[Unsupported JDBC type %d]", jdbc_type_id);
		sf_write_log_msg_mm(ALOG_ERROR, jdbc_type_id, errstr,
					"xml2db_jdbc_datatype_id_to_native()");
	}

	return (-999);	/* usually type <= -1 are illegal in all databases */

} /* end of xml2db_jdbc_datatype_id_to_native() */





char *xml2db_describe_jdbc_datatype_id(int jdbc_type_id)
/*
 * Return a string that describe this JDBC datatype.
 */
{
 static char	errstr[80] = "[other?]";

	switch (jdbc_type_id) {
	case JAVA_SQL_BIGINT:
		return ("JAVA_SQL_BIGINT");
	case JAVA_SQL_BINARY:
		return ("JAVA_SQL_BINARY");
	case JAVA_SQL_BIT:
		return ("JAVA_SQL_BIT");
	case JAVA_SQL_CHAR:
		return ("JAVA_SQL_CHAR");
	case JAVA_SQL_DATE:
		return ("JAVA_SQL_DATE");
	case JAVA_SQL_DECIMAL:
		return ("JAVA_SQL_DECIMAL");
	case JAVA_SQL_DOUBLE:
		return ("JAVA_SQL_DOUBLE");
	case JAVA_SQL_FLOAT:
		return ("JAVA_SQL_FLOAT");
	case JAVA_SQL_INTEGER:
		return ("JAVA_SQL_INTEGER");
	case JAVA_SQL_LONGVARBINARY:
		return ("JAVA_SQL_LONGVARBINARY");
	case JAVA_SQL_LONGVARCHAR:
		return ("JAVA_SQL_LONGVARCHAR");
	case JAVA_SQL_NULL:
		return ("JAVA_SQL_NULL");
	case JAVA_SQL_NUMERIC:
		return ("JAVA_SQL_NUMERIC");
	case JAVA_SQL_OTHER:
		return ("JAVA_SQL_OTHER");
	case JAVA_SQL_REAL:
		return ("JAVA_SQL_REAL");
	case JAVA_SQL_SMALLINT:
		return ("JAVA_SQL_SMALLINT");
	case JAVA_SQL_TIME:
		return ("JAVA_SQL_TIME");
	case JAVA_SQL_TIMESTAMP:
		return ("JAVA_SQL_TIMESTAMP");
	case JAVA_SQL_TINYINT:
		return ("JAVA_SQL_TINYINT");
	case JAVA_SQL_VARBINARY:
		return ("JAVA_SQL_VARBINARY");
	case JAVA_SQL_VARCHAR:
		return ("JAVA_SQL_VARCHAR");
	default:
		break;
	}
	sprintf(errstr, "[Unknown JDBC type %d]", jdbc_type_id);

	return (errstr);

} /* end of xml2db_describe_jdbc_datatype_id() */





void *xml2db_create_param_struct(char *name,
				 int   datatype,
				 int   is_null,
				 int   is_output,
				 char *str_value,
				 char *opt_size)
/*
 * Called by:	xmltp_parser_build_param()
 *
 * Create a parameter structure.
 *
 * Arguments:
 *	char *name	-- a string, name of the parameter
 *	int   datatype	-- a JDBC datatype, see javaSQLtypes.h
 *			-- probably needs to be converted to native value
 *	int   is_null	-- 1 if NULL,   0: non-NULL
 *	int   is_output -- 1 if output, 0: input parameter (normal)
 *	char *str_value	-- pointer to string value
 *			-- might need to be converted to native value
 *
 * Return:
 *	NULL		out of memory, or invalid arguments (see log)
 *	(void *)	pointer to a native parameter structure
 */
{
	CT10_DATA_XDEF_T	*p_new = NULL;
	int			 syb_type = -1;
	int			 b_initial_size_zero = 0;
	CS_INT			 outl = 0;
	CS_RETCODE		 rc   = 0;
	char			*p_value;
	char			work_buffer[MAX_SYB_VALUE_SIZE+1];
	/*
	 * data structure used for conversion with cs_convert(),
	 * which is the standard Sybase CS-Lib function:
	 */
	CS_DATAFMT		 src_fmt;

	if (s_debug_level >= DEBUG_TRACE_LEVEL_FULL) {
		sprintf(s_msg_buff, "xml2db_create_param_struct: name[%s] datatype[%d] is_null[%d] is_output[%d] str_value[%s] opt_size[%s]",
			name, datatype, is_null, is_output, str_value, opt_size);
		sf_write_error_to_log(ALOG_INFO, 0, s_msg_buff);
	}

	syb_type = xml2db_jdbc_datatype_id_to_native(datatype);
	if (syb_type <= -1) {
		sf_write_log_msg_mm(ALOG_ERROR, datatype, "Unsupported datatype in parameter",
				xml2db_describe_jdbc_datatype_id(datatype) );
		return (NULL);
	}

	p_new = (CT10_DATA_XDEF_T *) calloc(1, sizeof(CT10_DATA_XDEF_T));
	if (NULL == p_new) {
		sf_write_error_to_log(ALOG_ERROR, -1,
			 "*** Out of memory when creating a CT10_DATA_XDEF_T");
		return (NULL);
	}
	/*
	 * After this point any error recovery should also free p_new...
	 */

	p_new->fmt.datatype = syb_type;
	p_new->fmt.count  = 1;
	p_new->fmt.locale = NULL;
	p_new->null_ind   = 0;
	if (is_null) {
		p_new->null_ind = -1;
	}

	/* Copy the parameter name:
	 */
	ct10strncpy(p_new->fmt.name, name, CS_MAX_NAME);

	/* Adjust parameter name size.
	 */
	if (strlen(name) == 0) {
		p_new->fmt.namelen = 0;
	} else {
		p_new->fmt.namelen = CS_NULLTERM;
	}

	/* Set output-input indicator.
	 */
	if (!is_output) {
		p_new->fmt.status = CS_INPUTVALUE;
	} else {
		p_new->fmt.status = CS_RETURN;
	}

	/* This step is important, later p_value could point */
	/* to the convertion buffer if markup delimiter are  */
	/* find.                                             */

	p_value = str_value;

	/* Find out:
	 *   p_new->len
	 *   p_new->fmt.maxlength
	 *	(.maxlength is the number of bytes that we must allocate
	 * 	 for p_new->p_val)
	 */
	switch (syb_type) {
	case CS_INT_TYPE:
		p_new->len = 4;
		p_new->fmt.maxlength = 4;
		break;
	case CS_FLOAT_TYPE:
		p_new->len = 8;
		p_new->fmt.maxlength = 8;
		break;
	case CS_DATETIME_TYPE:
		p_new->len = 8;
		p_new->fmt.maxlength = 8;
		break;
	case CS_CHAR_TYPE:


		if ( (rc = xmltp_decode(p_value, work_buffer)) == 1) {
			p_value = work_buffer;
		} 

		p_new->len = strlen(p_value);
		/*
		 * Empty string must be processed as len 1
		 */
		if (0 == p_new->len) {
			b_initial_size_zero = 1;	/* True */
			p_new->len = 1;
		}


		if (opt_size != NULL ) {

			if ( (atoi(opt_size) < 0) || (atoi(opt_size) > CS_MAX_CHAR) ) {
				sf_write_log_msg_mm(ALOG_ERROR, atoi(opt_size), "xml2db_create_param_struct()",
						"[Invalid char size]" );
				free(p_new);
				return (NULL);
			}

			if (atoi(opt_size) != 0) {

				if (atoi(opt_size) < p_new->len) {
					sf_write_log_msg_mm(ALOG_ERROR, 
							atoi(opt_size), 
							"xml2db_create_param_struct()",
							"[Actual string len dont match char size]" );
					free(p_new);
					return (NULL);
				}

			}

		}

		p_new->fmt.maxlength = CS_MAX_CHAR;


		/*****
		if ( (opt_size == NULL ) || (atoi(opt_size) == 0) ) {
			p_new->fmt.maxlength = ( (p_new->len) + 1 );
		}
		else {

			if ( (atoi(opt_size) < 0) || (atoi(opt_size) > CS_MAX_CHAR) ) {
				sf_write_log_msg_mm(ALOG_ERROR, atoi(opt_size), "xml2db_create_param_struct()",
						"[Invalid char size]" );
				free(p_new);
				return (NULL);
			}
			else {
				if (atoi(opt_size) <= p_new->len) {
					sf_write_log_msg_mm(ALOG_ERROR, 
							atoi(opt_size), 
							"xml2db_create_param_struct()",
							"[Actual string len dont match char size]" );
					free(p_new);
					return (NULL);
				}
				else {
					p_new->fmt.maxlength = atoi(opt_size);
				}
			}

		}
		********/


		break;
	default:
		sf_write_log_msg_mm(ALOG_ERROR, datatype, "xml2db_create_param_struct()",
				"[Abnormal fall in default: (1)]" );
		free(p_new);
		return (NULL);
	}

	/*
	 * Allocate memory to put the value:
	 */
	p_new->p_val = (void *) calloc(1, p_new->fmt.maxlength);

	if (NULL == p_new->p_val) {
		sf_write_log_msg_mm(ALOG_ERROR, p_new->fmt.maxlength, "xml2db_create_param_struct()",
				"Out of memory for p_new->p_val" );
		free(p_new);
		return (NULL);
	}

	/*
	 * If (is_null), we do NOT copy the value (?) in p_new->p_val.
	 * We can return immediately.
	 */
	if (is_null) {
		return (p_new);		/* NULL parameter, we are done */
	}		
	

	/* Copy the value to p_new->p_val :
	 */
	switch (p_new->fmt.datatype) {
	case CS_DATETIME_TYPE:
	case CS_FLOAT_TYPE:
	case CS_INT_TYPE:
		/* Prepare the source CS_DATAFMT.
		 * the value source is a nul-terminated string.
		 */
	 	memset(&src_fmt, 0, sizeof(src_fmt) );
		src_fmt.datatype  = CS_CHAR_TYPE;
		src_fmt.maxlength = strlen(p_value);
		src_fmt.locale    = NULL;

		rc = cs_convert( ct10api_get_context(),
				&src_fmt,
				 p_value,
				&(p_new->fmt),
				 p_new->p_val,
				&outl );
		if (rc == CS_FAIL) {
			sf_write_log_msg_mm(ALOG_ERROR, p_new->fmt.datatype,
			  "cs_convert() failed in xml2db_create_param_struct(), value:",
			  p_value);
			free(p_new->p_val);
			free(p_new);
			s_params_err_ind=1;
			return (NULL);
		}
		/* Set format to unused.
		 */
		p_new->fmt.format = CS_FMT_UNUSED;
		break;
	case CS_CHAR_TYPE:
		if (b_initial_size_zero) {
			ct10strncpy( (char *)  p_new->p_val,
				    " ",
				    p_new->fmt.maxlength );
		} else {
			ct10strncpy( (char *)  p_new->p_val,
				    p_value,
				    p_new->fmt.maxlength );
		}
		/* Set format to null-terminated:
		 */
		p_new->fmt.format = CS_FMT_NULLTERM;
		break;
	default:
		sf_write_log_msg_mm(ALOG_ERROR, p_new->fmt.datatype, "xml2db_create_param_struct()",
				"[Abnormal fall in default: (2)]" );
		free(p_new->p_val);
		free(p_new);
		return (NULL);
	}

	return (p_new);

} /* end of xml2db_create_param_struct() */





int xml2db_free_param_struct(void *p_param)
/*
 * Destroy a parameter structure that had been created by
 * xml2db_create_param_struct().
 *
 * Afterwards, the calling program should not referenced again p_param.
 *
 * Return:
 *	0	p_param was a valid parameter structure
 *	-1	p_param was NULL
 *	<= -2	p_param was not a valid struct (detection not guaranteed)
 */
{
	CT10_DATA_XDEF_T	*p = NULL;
	int			 rc = 0;

	rc = sf_check_ct10_data_xdef_is_valid(p_param, "xml2db_free_param_struct():");
	if (rc != 0) {
		return (rc);
	}
	p = (CT10_DATA_XDEF_T *) p_param;

	/* Free the memory:
	 */
	if (p->p_val != NULL) {
		free(p->p_val);
		p->p_val = NULL;
	}
	free(p);

	return (0);

} /* end of xml2db_free_param_struct() */





char *xml2db_get_name_of_param(void *p_param)
/*
 * Return the name of the parameter held in *p_param.
 *
 * Return:
 *	NULL	p_param was NOT a valid parameter structure
 *	char *	name of the parameter
 */
{
	CT10_DATA_XDEF_T	*p = NULL;
	int			 rc = 0;

	rc = sf_check_ct10_data_xdef_is_valid(p_param, "xml2db_get_name_of_param() :");
	if (rc != 0) {
		return (NULL);
	}
	p = (CT10_DATA_XDEF_T *) p_param;

	return (p->fmt.name);

} /* end of xml2db_get_name_of_param() */



/***********************************
 *
 * Kill another xml2syb process.
 * The process number is get
 * as a int parameter from
 * the TRGX.
 * 
 ***********************************/

void sf_kill_process (
	void	*tab_params[], 
	int	nb_params,
	int	*p_return_status ) {


	long			rc, err;
	CT10_DATA_XDEF_T        **pt_params;
	void			*p_ctx	= NULL;

	p_ctx = (void *) xmltp_lex_get_single_thread_context();

	pt_params = (CT10_DATA_XDEF_T**) tab_params;

	/* A valid login is required before kill is accepted */
	if (s_db_connection_is_active == 0) {
		sprintf(s_msg_buff, "sf_kill_process: kill request but no valid connection active");
		sf_write_error_to_log(ALOG_WARN, 0, s_msg_buff);
		rc = RPC_RETURN_STAT_FOR_NO_DS_CONN;
	}
	else {

	/* If we have 1 parameter (the pid) we try the kill */
	if (nb_params == 1) {
		if ( (kill ( *((int *) (pt_params[0])->p_val), SIGTERM)) != 0 ) {

			err = errno;
			sprintf(s_msg_buff, "sf_kill_process: kill fail pid[%d], errno[%d]", *((int *) (pt_params[0])->p_val), err );
			sf_write_error_to_log(ALOG_INFO, 0, s_msg_buff);
			rc = 402;
		}
		else {

			sprintf(s_msg_buff, "sf_kill_process: kill done pid[%d]", *((int *) (pt_params[0])->p_val) );
			sf_write_error_to_log(ALOG_INFO, 0, s_msg_buff);
			rc = 0;
		}
	}
	else {
		sprintf(s_msg_buff, "sf_kill_process: call with bad argument");
		sf_write_error_to_log(ALOG_WARN, 0, s_msg_buff);
		rc=401;

	} /* End of if (nb_params == 1) */

	} /* End of if (s_db_connection_is_active == 0) */

	xmltp_writer_end_response(p_ctx, rc, 0, 1);

} /* End of sf_kill_process */



/*
 * Extract login & password from tab_params.
 * Change login & password into ct10api.
 * Exec a dummy strored to make sure connection is good or
 * just connect....
 * Check status of connection.
 * Fake resultset with PID  and return status
 */

void sf_process_db_login (
	void	*tab_params[], 
	int	nb_params,
	int	*p_return_status ) {


	char			password[RP_DB_LOGIN_PARAM_PASSWORD_SIZE+1];
	long			rc;
	CT10_DATA_XDEF_T        **pt_params;
	void			*p_ctx	= NULL;
	int			ret_stat=0;

	p_ctx = (void *) xmltp_lex_get_single_thread_context();

	pt_params = (CT10_DATA_XDEF_T**) tab_params;


	/* First param is username */
	/***************************/

	if ( (pt_params[RP_DB_LOGIN_PARAM_USERNAME_POSI])->len > RP_DB_LOGIN_PARAM_USERNAME_SIZE ) {
		sprintf(s_msg_buff, "sf_process_db_login: username len [%ld] to long", 
			(pt_params[RP_DB_LOGIN_PARAM_USERNAME_POSI])->len);

		sf_write_error_to_log(ALOG_ERROR, 0, s_msg_buff);
		return;
	}

	strncpy(	s_user_name,
			(char *) (pt_params[RP_DB_LOGIN_PARAM_USERNAME_POSI])->p_val,
			(pt_params[RP_DB_LOGIN_PARAM_USERNAME_POSI])->len);

	s_user_name[(pt_params[RP_DB_LOGIN_PARAM_USERNAME_POSI])->len ] = '\0';

	if (s_debug_level >= DEBUG_TRACE_LEVEL_LOW) {

		sprintf(s_msg_buff, "sf_process_db_login: username[%.8s], len[%ld]", 
			s_user_name,
			 (pt_params[RP_DB_LOGIN_PARAM_USERNAME_POSI])->len);

		sf_write_error_to_log(ALOG_INFO, 0, s_msg_buff);
	}


	/* Second param is passsword */
	/*****************************/

	if ( (pt_params[RP_DB_LOGIN_PARAM_PASSWORD_POSI])->len > RP_DB_LOGIN_PARAM_PASSWORD_SIZE ) {
		sprintf(s_msg_buff, "sf_process_db_login: password len [%ld] to long", 
			(pt_params[RP_DB_LOGIN_PARAM_PASSWORD_POSI])->len);

		sf_write_error_to_log(ALOG_ERROR, 0, s_msg_buff);
		return;
	}

	strncpy(	password,
			(char *) (pt_params[RP_DB_LOGIN_PARAM_PASSWORD_POSI])->p_val,
			(pt_params[RP_DB_LOGIN_PARAM_PASSWORD_POSI])->len);

	password[(pt_params[RP_DB_LOGIN_PARAM_PASSWORD_POSI])->len ] = '\0';

	if (s_debug_level >= DEBUG_TRACE_LEVEL_LOW) {

		sprintf(s_msg_buff, "sf_process_db_login: password[%.32s], len[%ld]",
				 password, (pt_params[RP_DB_LOGIN_PARAM_PASSWORD_POSI])->len);

		sf_write_error_to_log(ALOG_INFO, 0, s_msg_buff);
	}


	/* third param is TRG name */
	/***************************/

	if ( (pt_params[RP_DB_LOGIN_PARAM_TRG_NAME_POSI])->len > RP_DB_LOGIN_PARAM_TRG_NAME_SIZE ) {
		sprintf(s_msg_buff, "sf_process_db_login: TRG name len [%ld] to long", (pt_params[RP_DB_LOGIN_PARAM_TRG_NAME_POSI])->len);

		sf_write_error_to_log(ALOG_ERROR, 0, s_msg_buff);
		return;
	}

	strncpy(	s_trg_name,
			(char *) (pt_params[RP_DB_LOGIN_PARAM_TRG_NAME_POSI])->p_val,
			(pt_params[RP_DB_LOGIN_PARAM_TRG_NAME_POSI])->len);

	s_trg_name[(pt_params[RP_DB_LOGIN_PARAM_TRG_NAME_POSI])->len ] = '\0';

	if (s_debug_level >= DEBUG_TRACE_LEVEL_LOW) {
		sprintf(s_msg_buff,"sf_process_db_login: TRG name[%.32s], len[%ld]", 
				s_trg_name, (pt_params[RP_DB_LOGIN_PARAM_TRG_NAME_POSI])->len);
		sf_write_error_to_log(ALOG_INFO, 0, s_msg_buff);
	}


	/* Change password & login in ct10api */
	/**************************************/

	if ( (rc =  ct10api_change_connection_params(   
					s_p_server_conn,
                                        s_user_name,
                                        password,
                                        NULL,
                                        NULL,
                                        NULL) ) != CT10_SUCCESS) {

		sprintf(s_msg_buff,"sf_process_db_login: ct10api_change_connection_params error rc [%d]", rc);
		sf_write_error_to_log(ALOG_ERROR, 0, s_msg_buff);
		ret_stat = RPC_RETURN_STAT_FOR_NO_DS_CONN;
	}
	else {
		/* connect to database server */
		if (( rc = ct10api_connect(s_p_server_conn) ) != CT10_SUCCESS) {
			sprintf(s_msg_buff,"sf_process_db_login: ct10api_connect error rc [%d]", rc);
			sf_write_error_to_log(ALOG_ERROR, 0, s_msg_buff);
			ret_stat = RPC_RETURN_STAT_FOR_NO_DS_CONN;
			s_db_connection_is_active = 0;
		}
		else {
			ret_stat = 0;
			s_db_connection_is_active = 1;
		}
	}

	/* Fake xml result PID, return stat */
	/************************************/

	sprintf(s_msg_buff, "%ld", getpid());
	
	xmltp_writer_begin_result_set(p_ctx, 1, 0);

	xmltp_writer_column_name(p_ctx, "PID", 4, 0);

	xmltp_writer_column_value(p_ctx, 4, FALSE, s_msg_buff);

	xmltp_writer_end_colum_values(p_ctx);

	xmltp_writer_end_response(p_ctx, ret_stat, 0, 1);

	if (ret_stat != 0) {
		xml2db_abort_program(ret_stat, "sf_process_db_login", "Impossible to login to database server, must abort");
	}

} /* End of sf_process_db_login() */




void sf_send_back_return_status(int ret_stat)
/* 
 * Called by:	sf_check_and_process_registered_proc()
 */
{
	void	*p_ctx	= NULL;

	p_ctx = (void*) xmltp_lex_get_single_thread_context();

	xmltp_writer_end_response(p_ctx, ret_stat, 0, 0);

} /* end of sf_send_back_return_status() */



/*
 * Look for registered procedure in xml2syb and execute it.
 */

static int sf_check_and_process_registered_proc (
			char	*proc_name, 
			void	*tab_params[], 
			int	nb_params,
			int	*p_return_status )  {

	if (s_debug_level >= DEBUG_TRACE_LEVEL_LOW) {
		sprintf(s_msg_buff,"sf_check_and_process_registered_proc: proc_name[%.30s]", proc_name);
		sf_write_error_to_log(ALOG_INFO, 0, s_msg_buff);
	}

	if (strcmp(proc_name, REG_PROC_DB_LOGIN) == 0) {

		sf_process_db_login (	tab_params, 
					nb_params,
					p_return_status );

		return 1;

	} else if (strcmp(proc_name, REG_PROC_XML2DB_DEBUG_LOW) == 0) {

		xmltp_ctx_assign_debug_level( 1 );	/* 1 is low */

		sf_write_error_to_log(ALOG_INFO, 0, proc_name);

		sf_send_back_return_status( 0 );
		return 1;

	} else if (strcmp(proc_name, REG_PROC_XML2DB_DEBUG_FULL) == 0) {

		xmltp_ctx_assign_debug_level( 10 );	/* 10 is Full */

		sf_write_error_to_log(ALOG_INFO, 0, proc_name);

		sf_send_back_return_status( 0 );
		return 1;


	} else if (strcmp(proc_name, REG_PROC_XML2DB_PING) == 0) {	/* this "ping" write an entry in the log */

		sf_reset_static_values();	/* set begin timestamp */

		s_rpc_return_status = 0;

		sf_send_back_return_status( 0 );

		sf_log_rpc(proc_name);		/* write elapsed time (ms) in  the (server).log */

		return 1;

	} else if (strcmp(proc_name, REG_PROC_PING) == 0) {	/* this "ping" does NOT have timestamp or logging */

		s_rpc_return_status = 0;

		sf_send_back_return_status( 0 );

		return 1;

	} else if (strcmp(proc_name, REG_PROC_KILL) == 0) {

		sf_kill_process (	tab_params, 
					nb_params,
					p_return_status );

		return 1;
	}

	return 0;

} /* End of sf_check_and_process_registered_proc() */



/*
 * This function is use to change the rowcount limit on
 * an active connection. The init string of ct10api must
 * be change. This is the only way to automate SQL statement
 * inside of ct10api if the connection must be close and repoen.
 *
 * Since the init string is only execute by ct10api when openning 
 * a new connection we need to send a language event on the
 * active connection to change the current default.
 *
 * Stored procedure can also change the rowcount but
 * it wont affect the connection default it will 
 * only be effective inside of the stored proc.
 * This was test with sybase 12, I dont know
 * what will append with older version of sybase.
 *
 * The changing of rowcount inside of a stored proc
 * must be discourage as much as possible unless it's
 * to change the limit to a lower value.
 * 
 * VB limit is 2000, we are looking at lower value
 * for web (250-500), batch cig as a limit in 
 * the 100,000 range. 
 *
 */

int sf_set_rowcount(void *p_conn, char *rowcount)
{
	char wrk_buf[100];
	int  rc;

	if (s_debug_level >= DEBUG_TRACE_LEVEL_LOW) {
		sprintf(s_msg_buff,"sf_set_rowcount: New rowcount requested [%10s]",
			(rowcount == NULL) ? rowcount : "NULL"	); 
		sf_write_error_to_log(ALOG_INFO, 0, s_msg_buff);
	}

	strncpy(wrk_buf, SET_ROWCOUNT_SQL_STRING, sizeof(wrk_buf) );

	if ( rowcount == NULL ) {
		strncat(wrk_buf, DEFAULT_ROWCOUNT_VALUE, sizeof(wrk_buf));
	}
	else {
		strncat(wrk_buf, rowcount, sizeof(wrk_buf));
	}

	if ( ( rc = ct10api_change_and_exec_init_string(p_conn ,wrk_buf)) != CT10_SUCCESS ) {

		sprintf(s_msg_buff,"sf_set_rowcount:  ct10api_change_and_exec_init_string error rc [%d]", rc); 
		sf_write_error_to_log(ALOG_INFO, 0, s_msg_buff);
	
		return 1; /* FAIL */
	}
	else {
		if (s_debug_level >= DEBUG_TRACE_LEVEL_LOW) {
			sprintf(s_msg_buff,"sf_set_rowcount: New rowcount apply [%.40s]", wrk_buf); 
			sf_write_error_to_log(ALOG_INFO, 0, s_msg_buff);
		}

		return 0; /* SUCCESS */
	
	}
	

} /* End of sf_set_rowcount() */



/* Here we must do as the old cig, return just a few        */
/* standard return status for database connection problems. */

int sf_convert_ct10api_diag_mask_into_std_return_stat( int diag_mask )
{
	if (s_debug_level >= DEBUG_TRACE_LEVEL_LOW) {
		sprintf(s_msg_buff,"sf_convert_ct10api_diag_mask_into_std_return_stat: diag_mask [%x]", 
			diag_mask); 
		sf_write_error_to_log(ALOG_INFO, 0, s_msg_buff);
	}

	if ( diag_mask & CT10_DIAG_TIMEOUT ) {
		return RPC_RETURN_STAT_FOR_TIMEOUT;

	} else if ( ( diag_mask& CT10_DIAG_DISCONNECTED_BY_PEER ) ||
       		    ( diag_mask& CT10_DIAG_DEAD_CONNECTION ) )	{
		return RPC_RETURN_STAT_FOR_NO_DS_CONN;

	} else if (diag_mask& CT10_DIAG_DEADLOCK ) {
		return RPC_RETURN_STAT_FOR_DEADLOCK;

	} else  {
		return RPC_RETURN_STAT_FOR_FATAL;
	}

} /* --- End of sf_convert_ct10api_diag_mask_into_std_return_stat ----- */



/*****************************************************************************
 Retry can only be done before 10 seconds 

 ct10api rpc timeout is set to 100 seconds. If we retry after a maximum of
 10 seconds we garanty a maximum timeout of 110 seconds.

 For now we retry only on deadlock and bad connection stuff.
 It dont make sense to retry on timeout since it wont append in the first 10
 seconds.
 *****************************************************************************/

int sf_retry_rpc(int diag_mask)
{
sf_save_end_time();

if (s_debug_level >= DEBUG_TRACE_LEVEL_LOW) {
	sprintf(s_msg_buff,"sf_retry_rpc: diag_mask [%x] time [%d]",
		diag_mask, sf_delta_tval_in_ms(&st_tval_begin_rpc, &st_tval_end_rpc)); 
	sf_write_error_to_log(ALOG_INFO, 0, s_msg_buff);
}


if (sf_delta_tval_in_ms(&st_tval_begin_rpc, &st_tval_end_rpc) >= MAX_RETRY_TIME_MS) {
	return FALSE;
}
else {
	if ( diag_mask & CT10_DIAG_DEADLOCK ) {
		return TRUE;
	} else if ( diag_mask & CT10_DIAG_DISCONNECTED_BY_PEER ) {
		return TRUE;
	} else if ( diag_mask & CT10_DIAG_DEAD_CONNECTION ) {
		return TRUE;
	} else  {
		return FALSE;
	}
}

} /* ------------------- End of sf_retry_rpc -------------------- */



static int sf_return_status_is_one_to_retry(return_status)
/*
 * Called by:	xml2db_exec_proc()
 *
 * Return:	0	if return_status is NOT one of the values of RETRY_ON_THOSE_RETURN_STATUS
 *			or if that parameter is not in the config file.
 *		1	if return_status IS one of the values of RETRY_ON_THOSE_RETURN_STATUS
 */
{
 char	str[100] = "??";
 
 sprintf(str, "%d", return_status);

 if (ucfg_is_string_in_param_values_list(CONFIG_STRING_RETRY_ON_THOSE_RETURN_STATUS, str) ) {
 	return (1);
 }
 return 0;

} /* end of sf_return_status_is_one_to_retry() */

int xml2db_exec_proc(void *p_conn, char *proc_name, 
		void *tab_params[], int nb_params,
		int  *p_return_status)
/*
 * Call the database procedure proc_name with parameters given in tab_params[].
 *
 * Each parameter pointers to by the pointers in tab_params must have been
 * created with xml2db_create_param_struct().
 *
 * Return:
 *	0	OK
 */
{
	CS_INT	 return_status	= 0;
	int	 rc		= 0;
	int	 retry_count	= 0;

	sf_reset_static_values();

	if (NULL == p_conn) {
		p_conn = s_p_server_conn;
	}

	/*
	 * Here, we assign s_current_active_conn so that sf_handle_error_msg()
	 * can find the name of the server:
	 */
	s_current_active_conn = p_conn;

	xmltp_writer_reset( (void*) xmltp_lex_get_single_thread_context() );



	/* Here we process registerd procedure            */
	/* Return 1 if the proc_name is a registered proc */
	/* If so we get out of here, the function that    */
	/* handle the Reg Proc will fake the necessery    */
 	/* result. 					  */

	if ( sf_check_and_process_registered_proc (
						proc_name, 
						tab_params, 
						nb_params,
						p_return_status) != 0 ) {

		return 0;
	}



	/* If registered proc for databse login not call yet */
	/* We return -1100 */

	if (s_db_connection_is_active == 0) {
		s_rpc_return_status = RPC_RETURN_STAT_FOR_NO_DS_CONN;
		xmltp_writer_end_response( (void*) xmltp_lex_get_single_thread_context(),
				  	s_rpc_return_status, 0, s_last_result_set_nb_rows);
		sf_log_rpc(proc_name);
		return 0;
	}


	sf_check_and_set_intercept_xid(proc_name);
	retry_count = 0;

	/* A global is require because it will be set inside of the callback function. */
	s_timeout_ind = 0;

	while (1)
	{
		++retry_count;
		if ( s_params_err_ind == 1 ) {
			sf_write_error_to_log(ALOG_ERROR, rc,
				"Problem while parsing parameters, xml2syb is terminated");
			xmltp_writer_end_response(	(void*) xmltp_lex_get_single_thread_context(),
				       			RPC_RETURN_STAT_FOR_FATAL, 0, 1);

			return 0;
		}

		rc = ct10api_exec_rpc( p_conn, proc_name,
				       (CT10_DATA_XDEF_T **) tab_params,
				       nb_params,
				       &return_status );

		if ( s_timeout_ind == 1 ) {

			sf_write_error_to_log(ALOG_ERROR, rc,
				"RPC Timeout while processing results, xml2syb is terminated");

			rc = ct10api_close_connection(p_conn);

			xmltp_writer_end_response(	(void*) xmltp_lex_get_single_thread_context(),
				       			RPC_RETURN_STAT_FOR_TIMEOUT, 0, 1);

			exit (50);
		}
		/***
		sprintf(s_msg_buff,"sf_retry_rpc: rc[%d] action mask[%x] result state mask[%x] retry count[%d] sf_retry[%d]", 
				rc,
			       	ct10api_get_action_mask(p_conn),
				ct10api_get_result_state_mask(p_conn),
				retry_count,
				sf_retry_rpc(ct10api_get_diagnostic_mask(p_conn)) ); 

		sf_write_error_to_log(ALOG_INFO, 0, s_msg_buff);
		***/

		if (s_debug_level >= DEBUG_TRACE_LEVEL_LOW) {
			sprintf(s_msg_buff,"xml2db_exec_proc:retry info,rc[%d],diag mask[%x],result state mask[%x],retry count[%d]",
				rc, ct10api_get_diagnostic_mask(p_conn), ct10api_get_result_state_mask(p_conn), retry_count); 
			sf_write_error_to_log(ALOG_INFO, 0, s_msg_buff);
		}

		/* All these conditions are required to do a retry			*/
		/* exec_rpc return no success RC					*/
		/* Result are not already  present					*/
		/* Less than 10 seconds has passed and deadlock or bad connection	*/
		/* Dont use action mask from ct10api. Action mask will  tell you not    */
		/* to retry on deadlock by example and we do want to retry.		*/
		if (	(rc != CT10_SUCCESS) &&
	         	(ct10api_get_result_state_mask(p_conn) & CT10_RESULT_NOT_PRESENT) &&
			(retry_count < MAX_RETRY_COUNT) &&
		  	(sf_retry_rpc(ct10api_get_diagnostic_mask(p_conn)))
		    ||  (rc == CT10_SUCCESS 
		      && (retry_count < MAX_RETRY_COUNT)
		      && sf_return_status_is_one_to_retry(return_status) )   ) {
			/* If many errors in the life of this occurence of xml2syb, program must stop
			 */
			if (rc <= CT10_ERR_TOO_MANY_FATALS_ABORTED) {
				sf_write_error_to_log(ALOG_ERROR, rc,
					"*** FATAL ct10api error ABORTING ***");

				xmltp_writer_end_response(	(void*) xmltp_lex_get_single_thread_context(),
					       			RPC_RETURN_STAT_FOR_FATAL, 0, 1);
				exit (50);
			}
			else {
				/* Here we are in a retry situation, we should wait 1 second */
				sleep(1);

				/* ct10api report to reset the connection, we need to do it here */
				/* since retry is disable in ct10api for xml2syb 		 */

				if (ct10api_get_action_mask(p_conn) & RECOV_ACT_RESET_CONNECTION) {

					if (( rc = ct10api_connect(p_conn) ) != CT10_SUCCESS) {
						sprintf(s_msg_buff,"xml2db_exec_proc: ct10api_connect error rc [%d]", rc);
						sf_write_error_to_log(ALOG_ERROR, 0, s_msg_buff);
						xmltp_writer_end_response((void*) xmltp_lex_get_single_thread_context(),
					       				RPC_RETURN_STAT_FOR_NO_DS_CONN, 0, 1);
						exit (50);
					}
				}

				/* For now we want a trace of the retry in the log */
				sprintf(s_msg_buff,"xml2db_exec_proc:retry rpc,rc[%d],diag mask[%x],result state mask[%x],retry count[%d]",
					rc, ct10api_get_diagnostic_mask(p_conn), ct10api_get_result_state_mask(p_conn), retry_count); 
				sf_write_error_to_log(ALOG_INFO, 0, s_msg_buff);


			}

		}
		/* No retry possible we need a valid return status */
		else {
			/* Is almost impossible that return_status = -999 and rc = CT10_SUCCESS */
			/* but I check just in case */
			if ( return_status != -999 )  {
				s_rpc_return_status = return_status;
				break;
			}
			else {
				s_rpc_return_status = sf_convert_ct10api_diag_mask_into_std_return_stat(
							ct10api_get_diagnostic_mask(p_conn) );
				break;

			}

		} /* End of if we retry or not */
			

	} /* End of while (1) *0/

	/* Completes the XML reponse: */

	sf_write_error_msg(s_last_result_set_nb_rows);

	xmltp_writer_end_response( (void*) xmltp_lex_get_single_thread_context(),
				  s_rpc_return_status, 0, s_last_result_set_nb_rows);

	sf_log_rpc(proc_name); /* This is for oesyssrv.log */


	/* Here we log rpc_audit */

	rc = sf_write_rpc_audit_log_entry(	proc_name,
						tab_params,
                                        	nb_params,
                                        	rpc_audit_log_buffer,
                                        	MAX_RPC_AUDIT_LOG_BUFFER_SIZE,
						rpc_audit_buffer_posi);

	return (0);

} /* end of xml2db_exec_proc() */


/* ----------------------------------- Child process main loop: */


static int sf_process_client_connection(int child_socket)
{
	void	*p_ctx = NULL;
	int	 rc    = 0,
		 ctr_errs = 0,
		 b_found_eot;

	p_ctx = (void *) xmltp_lex_get_single_thread_context();


	rc = xmltp_ctx_assign_socket_fd(p_ctx, child_socket);
	if (rc != 0) {
		sf_write_error_to_log(ALOG_ERROR, rc,
			 "ABORTING: cannot assign socket into parser context");
		return (55);
	}
		
	sf_write_log_msg_mm(ALOG_INFO, child_socket,
				"Ready to parse from socket connection.",
				"");

	/* s_abort_flag could be set by xml2db_abort_program()
	 */
	while (!s_abort_flag) {

		if ( (rc = xmltp_ctx_reset_lexer_context(p_ctx)) != 0) {
			return (5);
		}

		/* For each new rpc we need to reset this value */
		s_params_err_ind = 0;

		/* NOTE: The functions called in the actions of the parser
		 * will do callbacks to various functions, including the
		 * xml2db_xxx() functions here.
		 */
		rc = yyparse(p_ctx);	/* the re-entrant parser generated by Bison 
					 * needs the p_ctx. (jft, 2002jan08)
					 */

		b_found_eot = xmltp_ctx_buffer_contains_eot(p_ctx);

		if (xmltp_ctx_get_b_eof_disconnect(p_ctx) ) {
			rc = 1;		/* force rc to indicate EOF, disconnect */

			if (s_debug_level >= DEBUG_TRACE_LEVEL_LOW) {
				sf_write_log_msg_mm(ALOG_INFO, 0, "Disconnect detected.", "");
			}
		} else if ( ( ctr_errs = xmltp_ctx_get_lexer_or_parser_errors_ctr(p_ctx)) != 0) {

			sprintf(s_msg_buff,"yyparse failed: ctr_err[%d], yyparse rc[%d], b_found_eot[%d], <EOT/>[%s], p_ctx[%x]",
				ctr_errs, rc, b_found_eot,
				xmltp_ctx_get_b_eof_disconnect(p_ctx) ? "Disc/EOF" : "No Disc/EOF",
				p_ctx);
			sf_write_log_msg_mm(ALOG_ERROR, 0, s_msg_buff, "");
		}

		switch (rc) {
		case 0:
			/* sf_write_log_msg_mm(ALOG_INFO, 0,
				"Request parsed completely without error.",
				""); */
			break;
		case 1:
		case 101:	/* EOF ?? */
			sf_write_log_msg_mm(ALOG_INFO, rc,
				"EOF in parser. This child process is stopping.",
				"");
			return (0);
		default:
			ctr_errs++;
			if (ctr_errs >= 5) {
				sf_write_error_to_log(ALOG_ERROR, rc,
				 "*** Too many XML-TP parse errors ABORTING ***");
				return (60);
			}
			sleep(1);	/* to avoid a hard loop */
		}
	} 

	sf_write_log_msg_mm(ALOG_WARN, getpid(),
				"XML-to-Sybase connection closing.",
				(s_abort_flag) ? "Abort flag set." : "(see reason before).");

	return (0);

} /* end of sf_process_client_connection() */



/* --------------------------------------------------------- Main(): */


int main(int argc, char **argv)
{
	int	 rc = 0;

#if 0	/* not used yet: */
	int	soc_size_buf;
#endif
	int	listen_socket	= -1,
		child_socket	= -1;

	pid_t	pid_child	= 0;

	char	msg_buff[200] = "[ms_buff?]";

	char xmltp_host_file[PATH_SIZE];

	char	*p = NULL;

	/* Standard ct10api initialization. */
 
	if ((rc =  ct10init_standard_ct10api_init(
                                        &s_p_server_conn,
                                        ARGUMENTS_STRING,
                                        argc,
                                        argv,
                                        CFG_SECTION,
                                        CT10INIT_CONFIF_PREFIX_IND_NONE,
                                        s_pgm_name,
                                        NULL
                        )) != CT10INIT_SUCCESS) {
 
        	sf_syntax(s_pgm_name);
        	exit(1);
 
	}

	/* Build path and name of xmltp_host file from environment variable */
	if (getenv(ENV_XMLTP) != NULL) {

		strncpy(xmltp_host_file, getenv(ENV_XMLTP), PATH_SIZE);

		if ( xmltp_host_file[strlen(xmltp_host_file)-1] != '/' ) {
			strncat(xmltp_host_file, "/", PATH_SIZE);
		}

		strncat(xmltp_host_file, XMLTP_HOST_FILE_NAME, PATH_SIZE);

	} else {
		sprintf(s_msg_buff,"XMLTP environment variable not set");
		sf_write_error_to_log(ALOG_ERROR, 0, s_msg_buff);
		exit(1);
	}

	/* get xmltp_hosts logical name from option or config file */
	if (ct10init_get_option_or_config_value(ARG_XMLTP_HOST_LOGICAL_NAME, 
						CONFIG_STRING_XMLTP_HOST_LOGICAL_NAME) != NULL) {
		if (rc = xmltp_hosts(	xmltp_host_file,
					ct10init_get_option_or_config_value(
							ARG_XMLTP_HOST_LOGICAL_NAME,
							CONFIG_STRING_XMLTP_HOST_LOGICAL_NAME),
					s_host_name,
					s_listen_port ) == 0 ) {

			sprintf(s_msg_buff, "logical[%s], hosts[%s], port[%s]", 
					ct10init_get_option_or_config_value(
								ARG_XMLTP_HOST_LOGICAL_NAME,
								CONFIG_STRING_XMLTP_HOST_LOGICAL_NAME),
					s_host_name,
					s_listen_port);

			sf_write_error_to_log(ALOG_INFO, 0, s_msg_buff);
		}
		else {
			sprintf(s_msg_buff,"logical name not found");
			sf_write_error_to_log(ALOG_ERROR, 0, s_msg_buff);
			exit(1);
		}
	} else {
		sprintf(s_msg_buff,"xmltp_hosts logical name required");
		sf_write_error_to_log(ALOG_ERROR, 0, s_msg_buff);
		exit(1);
	}

	/* get rowcount limit from ARG_ROWCOUNT_LIMIT, CONFIG_STRING_ROWCOUNT_LIMIT ...
	 */

/* #define DEBUG_GET_ROWCOUNT_LIMIT	1
 */

#ifdef DEBUG_GET_ROWCOUNT_LIMIT	 

	printf("ARGUMENTS_STRING=%s\n", ARGUMENTS_STRING);
	p = ct10init_get_option_or_config_value(ARG_ROWCOUNT_LIMIT, CONFIG_STRING_ROWCOUNT_LIMIT);
	printf("p = ct10init_get_option_or_config_value(%c, %s) \n", ARG_ROWCOUNT_LIMIT, CONFIG_STRING_ROWCOUNT_LIMIT);
	printf("p: %s\n", ((NULL == p) ? "[NULL]" : p)   );

	printf("pa_get_flag(ARG_ROWCOUNT_LIMIT) = %d\n", pa_get_flag(ARG_ROWCOUNT_LIMIT) );
	p = pa_get_arg(ARG_ROWCOUNT_LIMIT);
	printf("pa_get_arg(ARG_ROWCOUNT_LIMIT) = %s\n", ((NULL == p) ? "[NULL]" : p)   );
	if (p != NULL) {
		printf("atoi(p)=%d\n", atoi(p) );
	}
#endif

	if (ct10init_get_option_or_config_value(ARG_ROWCOUNT_LIMIT, 
						CONFIG_STRING_ROWCOUNT_LIMIT) != NULL) {

		s_row_count = 0;
		s_row_count = atoi(ct10init_get_option_or_config_value(	ARG_ROWCOUNT_LIMIT,
									CONFIG_STRING_ROWCOUNT_LIMIT));
		if (s_row_count == 0) {
			sprintf(s_msg_buff, "main: Invalid config or agument for ROWCOUNT_LIMIT, atoi failed, using default");
			sf_write_error_to_log(ALOG_WARN, 0, s_msg_buff);
			s_row_count = 2005;
		}

	}
	else {
		s_row_count = 2005;
	}

	ct10api_set_row_count(s_row_count);
	sprintf(s_msg_buff, "main: ROWCOUNT_LIMIT [%d]", s_row_count);
	sf_write_error_to_log(ALOG_INFO, 0, s_msg_buff);

	/* get exec timeout value */
	if (ct10init_get_option_or_config_value(ARG_EXEC_TIMEOUT, 
						CONFIG_STRING_EXEC_TIMEOUT) != NULL) {

		s_exec_timeout = 0;
		s_exec_timeout = atoi(ct10init_get_option_or_config_value(	ARG_EXEC_TIMEOUT,
									CONFIG_STRING_EXEC_TIMEOUT));


		if (s_exec_timeout == 0)  {
			sprintf(s_msg_buff, "main: Invalid config or agument for EXEC_TIMEOUT, atoi failed, using default [%d]", EXEC_TIMEOUT);
			sf_write_error_to_log(ALOG_WARN, 0, s_msg_buff);
			s_exec_timeout = EXEC_TIMEOUT;
		}

	}
	else {
		s_exec_timeout = EXEC_TIMEOUT;
	}

	if ( (rc = ct10api_change_exec_timeout_value(s_exec_timeout)) != CT10_SUCCESS ) {
		sprintf(s_msg_buff, "main: ct10api_change_exec_timeout_value failed, timeout [%d], rc [%d]", s_exec_timeout, rc);
		sf_write_error_to_log(ALOG_ERROR, 0, s_msg_buff);
		exit(1);
	}

	sprintf(s_msg_buff, "main: EXEC_TIMEOUT [%d]", s_exec_timeout);
	sf_write_error_to_log(ALOG_INFO, 0, s_msg_buff);

	/* this is more trouble then help ...
	if ( 	(getenv(SYBASE_LANG_VAR) == NULL) || 
		( strcmp(getenv(SYBASE_LANG_VAR), SYBASE_LANG_STRING) != 0 ) ) {

		sprintf(s_msg_buff,"'%.15s' environment variable not OK for sybase ct-lib [%.15s] [%.15s]",
					SYBASE_LANG_VAR, getenv(SYBASE_LANG_VAR), SYBASE_LANG_STRING);
		sf_write_error_to_log(ALOG_ERROR, 0, s_msg_buff);
        	exit(2);
	}
	*/

	/* We need to log the pid not the parent pid wich is the default */
	(void) alog_set_log_parent_pid_to_false();

	sf_log_init_msg(ALOG_INFO, 0, "INIT: Connection to", 
	ct10init_get_option_or_config_value(	CT10INIT_ARG_SERVER_NAME, 
						CT10INIT_CONFIG_STRING_SERVER_NAME));

	/* Log the name of rpc_audit file */
	sf_log_init_msg(ALOG_INFO, 0, "INIT: rpc_audit file", 
	ct10init_get_option_or_config_value(	ARG_RPC_AUDIT_LOG_NAME, 
						CONFIG_STRING_RPC_AUDIT_LOG_NAME));

	/* xml2syb debug trace level setting from option or config file */
	if ( ct10init_get_option_or_config_value(ARG_APPL_DEBUG_TRACE_LEVEL, 
						CONFIG_STRING_APPL_DEBUG_TRACE_LEVEL) != NULL ) {

		s_debug_level = atoi(ct10init_get_option_or_config_value(ARG_APPL_DEBUG_TRACE_LEVEL,
                                                CONFIG_STRING_APPL_DEBUG_TRACE_LEVEL) );

		/****
		if (errno != 0)  {
			sprintf(s_msg_buff, "main: invalid config or option for debug level [%.10s], intval [%d], errno [%d]",
				 ct10init_get_option_or_config_value(ARG_APPL_DEBUG_TRACE_LEVEL, 
						CONFIG_STRING_APPL_DEBUG_TRACE_LEVEL),
				 s_debug_level,
				 errno);
			sf_write_error_to_log(ALOG_ERROR, 0, s_msg_buff);

			s_debug_level	   = DEBUG_TRACE_LEVEL_NONE;

		}
		****/

	}

	sprintf(s_msg_buff, "main: debug level [%d]",s_debug_level);
	sf_write_error_to_log(ALOG_INFO, 0, s_msg_buff);


	/*
	 * Assign pointer to function for result set / row processing.
	 *
	 * sf_process_row() will return results to the client in XML.
	 *
	 */
	ct10api_assign_process_row_function(s_p_server_conn, sf_process_row);



	xmltp_ctx_assign_log_function_pf( sf_write_log_msg_mm);

	if (sf_init_cfg_log_ct10api() != 0) {
		exit(2);
	}

	listen_socket = sf_init_master_socket_listen();
	if (listen_socket <= -1) {
		exit(3);
	}

	signal( SIGCHLD, SIG_IGN );	/* maybe could be trapped & processed */
	signal( SIGPIPE, SIG_IGN );	/* happens the peer closes the socket */

	
	while (1) {
		child_socket = sock_accept_connection ( listen_socket );

		if ( child_socket <= -1 ) {
			if ( errno == EINTR ) {
				continue;
			}
			/* Connection problem:
			 */
			sf_write_log_msg_mm(ALOG_ERROR, errno,
				"MASTER LISTERNER ABORTING. sock_accept_connection() failed:",
				(char *) sys_errlist[errno] );
			
			exit( 1 );	/* @@@ comme tsession.c  OK??? */
			return (1);
		}
		/* we set the size of  the send buffer to avoid any  */
		/* waiting  in case of a broken connection between   */
		/* the child (tseesion) and the tsender */
#if 0
		soc_size_buf = 2 * sizeof( TSES_MSG );

		rc = setsockopt( child_socket,
				SOL_SOCKET,
				SO_SNDBUF,
				(char *)&soc_size_buf,
				sizeof( int ) );
#endif

		pid_child = fork();	/* --------- fork() --------- */

		switch ( pid_child ) {

		case 0:				/* Child */
			close( listen_socket );
			sf_write_log_msg_mm(ALOG_INFO, 0, "Child starting.",
						"close() master socket done." );
			
			return (sf_process_client_connection(child_socket));

		case -1	:			/* fork() ERROR */
			sf_write_log_msg_mm(ALOG_ERROR, errno,
				"FAILED. fork() failed. client socket closed.",
				(char *) sys_errlist[errno] );
		
			close( child_socket );
			return( 1 );

		default	:			/* Parent */
			close( child_socket );

			sprintf(msg_buff, "pid_child=%d", pid_child);

			sf_write_log_msg_mm(ALOG_INFO, pid_child,
				"Parent has one more child process. ",
				msg_buff);
			break;
		}
	}
	return (0);

} /* end of main() */


/* -------------------------------------- end of xml2syb.c ----------- */
