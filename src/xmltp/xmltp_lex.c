/*
 * xmltp_lex.c
 * ----------
 *
 *  Copyright (c) 2001-2003 Jean-Francois Touchette
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Library General Public
 *  License as published by the Free Software Foundation; either
 *  version 2 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Library General Public License for more details.
 *
 *  You should have received a copy of the GNU Library General Public
 *  License along with this library; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *  (The file "COPYING" or "LICENSE" in a directory above this source file
 *  should contain a copy of the GNU Library General Public License text).
 *  -------------------------------------------------------------------------
 *
 * $Source: /ext_hd/cvs/xmltp/xmltp_lex.c,v $
 * $Header: /ext_hd/cvs/xmltp/xmltp_lex.c,v 1.13 2003/09/07 20:09:38 toucheje Exp $
 *
 *
 * Custom lexer for the XML-TP syntax
 * ----------------------------------
 *
 * This lexer is written in "C" because Flex or Lex are not
 * re-entrant (Flex can create re-entrant lexer but, only in C++,
 * which seems like a source of un-needed complexity for such
 * a program as the CIG-X or TRG-X, already a Python/C hybrid).
 *	
 * 
 * NOTES: . version 0.2 and following are re-entrant if XMLTP_GX is defined.
 *	  . to get a .o module that re-entrant, compile with the
 *	    flag -DXMLTP_GX=1
 *	  . to get a .o module to be linked with a single-thread main()
 *	    (such as one implementing the xml2db.h API), compile WITHOUT
 *	    that flag.
 *
 * NOTE on XMLTP_GX define: In xmltp_lex.c, XMLTP_GX controls the passing
 *		of the argument YYSTYPE *p_lval to various functions.
 *		This allows thread-safe parsing and it is supported
 *		by the Bison parser generator (see "%pure_parser" and
 *		related features in the Bison documentation).
 *
!* NOTE on XMLTP_GX_PY : This define controls the conditional compile to use
!*		Python library functions and PyObject.
 *
 * ------------------------------------------------------------------------
 * 2001aug26,jft: begin first version, not re-entrant. Input from stdin.
 * 2001aug28,jft: with parse context
 * 2001aug29,jft: almost complete, not compiled yet
 * 2001sept03,jft: sf_match_tag(): also check for XMLTP_EOT_TAG, if found return 0.
 *		   removed: #define DEBUG oui
 * 2001sept10,jft: replaced calls to getc() by calls to xmltp_ctx_get_input_char(p_ctx)
 * 2001sept19,jft: #include "xmltp_ctx.h", not "xmltp_parser.h"
 * 2001oct10,jft;  #ifdef XMLTP_GX -- support for Bison "pure_parser" (re-entrant)
 *		   xml_lex_yylex1(): process CR '\r' like whitespace
 * 2001oct12,jft:  xml_lex_yylex1(): #ifdef XMLTP_GX, do not use yylineno
 * 2001oct15,jft:  #ifdef XMLTP_GX  #include "Python.h" (needed by "xmltp_ctx.h")
 *		   changed g_debug (extern) to static int s_debug_level
 * 2001nov16,jft: . yyerror(): only fprintf(stderr, "%s\n", s) #ifdef YYERROR_PRINT
 * 2002jan08,jft: adapted to let xml2syb uses Bison grammar (with XMLTP_GX defined)
 *		  removed 
 *		  function xmltp_lex_get_single_thread_context() created when #ifdef XML2DB
 *		  yyerror() contains #ifndef XML2DB
 * 2002jan14,jft: + static char *sf_check_keywords_table()
 * 2002feb03,jft: . sf_match_tag(), sf_get_value(): after each call to xmltp_ctx_get_input_char(p_ctx),
 *			EOF is checked as (c == -1), not as (c <= -1).  Because this was confused 
 *			with accented characters.
 *		  . xml_lex_yylex1(): added: case -1, not only case EOF.
 * 2003jun05,jft: #ifdef XMLTP_GX_PY controls the conditional compile to use Python objects 
 *		   and functions and PyObject.
 * 2003sep06,jft: . sf_check_received_eot(): fix to not include the trailing '>' in the constant to compare with.
 */

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>


#ifdef XMLTP_GX_PY
#include "Python.h"	/* to please function prototypes in xmltp_ctx.h */
#endif

#ifdef XMLTP_GX
#include "xmltp_gram.tab.h"	/* defines of tokens values, generated by Bison */
#else
#include "xml_para.h"	/* defines of tokens values, generated by YACC	 */
			/* also    extern YYSTYPE yylval;		 */
#endif

#include "xmltp_ctx.h"	/* for xmltp_ctx_XXX() functions and		*/
			  /* for VALUE_FOLLOWS_IS_xxx defines		*/
#include "xmltp_keyw.h"	  /* table of keywords (strings and tokens values) */
#include "xmltp_eot.h"	  /* for XMLTP_EOT_TAG				*/




/* --------------------------------------------- External variables: */


#ifndef XMLTP_GX
	int	yylineno;		/* GLOBAL here -- NOT for bison pure_parser */
#endif


/* -------------------- Private variables used for SINGLE-THREAD version: */

static	int   s_debug_level = 0;

static	void *s_p_single_parser_context = NULL;



/* ----------------------------------- Miscelaneous PUBLIC Functions: */

/* -------- Function to get the name of a token: */

char *xmltp_lex_get_name_from_token2_val(int token_val)
{
	switch(token_val) {
	case (STRVAL):	return ("STRVAL");
	default:		break;
	}
	return (NULL);
}


/* -------- Function to get the name of a keyword token: */

char *xmltp_lex_get_keyword_from_token_val(int token_val)
/*
 * uses struct from "mc_keyw.h" 
 */
{
  int	i, max;

  max = sizeof(s_keywords_tab) / sizeof(s_keywords_tab[0]);

  for (i = 0; i < max; i++) {
  	if (s_keywords_tab[i].token_val == token_val)
		return (s_keywords_tab[i].keyword);
  }

  return (NULL);
}


/* ------------------------------------------------ PRIVATE Functions: */


static char *sf_check_keywords_table()
/*
 * Called by:	xml_lex_yylex1() -- one time only.
 *
 * verify that entries in s_keywords_tab[] are sorted.
 */
{
static char	errmsg[200] = "[errmsg?]";
static int	b_already_said = 0;
	int	nb_entries = -1, 
		i = 0;

	nb_entries = (sizeof(s_keywords_tab) / sizeof(s_keywords_tab[0]) );
	for (i = 1; i < nb_entries; i++) {
		if (strcasecmp(s_keywords_tab[i-1].keyword, s_keywords_tab[i].keyword) > 0) {
			sprintf(errmsg, "ERROR: keywords table not sorted (in xmltp_keyw.h): %.30s > %.30s at %d",
					s_keywords_tab[i-1].keyword, s_keywords_tab[i].keyword, i );
			if (!b_already_said) {
				b_already_said = 1;
				fprintf(stderr, "\n%.180s.\n", errmsg);
			}
			return (errmsg);
		}
	}
	return (NULL);

} /* end of sf_check_keywords_table() */



static int sf_get_keyword_val(char *s, int *p_b_value_follows)
/* 
 * uses struct initialized in "xmltp_keyw.h"
 *
 * returns token_val or -33
 */
{
  int hi, lo, mid;
  int cmp_val;

  /* This is a binary search...
   */
  lo = 0;
  hi = (sizeof(s_keywords_tab) / sizeof(s_keywords_tab[0]) )  -  1;

  while (lo <= hi) {
	mid = (lo + hi) / 2;
	if ((cmp_val = strcasecmp(s, s_keywords_tab[mid].keyword)) == 0) {
		if (p_b_value_follows != NULL) {
			*p_b_value_follows = s_keywords_tab[mid].b_value_follows;
		}
		return (s_keywords_tab[mid].token_val);
	}
	if (cmp_val < 0) {
		hi = mid - 1;
	} else {
		lo = mid + 1;
	}
  }
  return (-33);		/* unknown keyword */

} /* end of sf_get_keyword_val() */





static int sf_check_received_eot(char *sbuf)
{
	char *p_eot_tag = XMLTP_EOT_TAG;
	int   n = 0;

	p_eot_tag++;		/* skip the initial '<' */

	n = strlen(p_eot_tag);	/* use length to ignore the trailing '>' in the constant */

	return (!strncmp(p_eot_tag, sbuf, (n - 1) ));	/* return True if match */

} /* end of sf_check_received_eot() */





#ifdef XMLTP_GX
static int sf_match_tag(YYSTYPE *p_lval, void *p_ctx)
#else
static int sf_match_tag(void *p_ctx )
#endif
{
  int	     c = 0,
	     b_value_follows = 0;
  int	     trunc_flag = 0,
  	     token_val  = 0;
  char	     sbuf[MAX_ONE_STRING] = "\0\0\0[not init]\0\0\0",
  	    *p = sbuf;

  while (1) {
	c = xmltp_ctx_get_input_char(p_ctx);
	if (c == -1) {
		xmltp_ctx_lexer_error(p_ctx, "unexpected EOF in sf_match_tag()", sbuf);
		return (-1);	/* unexpected EOF */
	}
	if ('>' == c) {
		break;
	}
	if (!trunc_flag  &&  p >= (sbuf + sizeof(sbuf) - 1)  ) {
		*p = '\0';
		xmltp_ctx_lexer_error(p_ctx, "Identifier truncated", sbuf);
		trunc_flag = 1;
	}
	if (!trunc_flag) {
		*p = (char) c;
		p++;
	}
  }
  if (!trunc_flag) {
	*p = '\0';
  }

  if (sf_check_received_eot(sbuf) ) {
	token_val = EOT;		/* now required by grammar, 2003sep06,jft */
	b_value_follows = 0;
  } else {
	token_val = sf_get_keyword_val(sbuf, &b_value_follows);
  }

#if 0
printf("sbuf[]='%s', token_val=%d\n", sbuf, token_val);
#endif
 
  if (token_val >= 0) {
	/*
	 * p_ctx->b_value_follows (if not 0) will tell the next call 
	 * to yylex() to get a value...
	 */  
	xmltp_ctx_assign_lexer_value_follows(p_ctx, b_value_follows);
  }
  /*
   * Give back the p_ctx in the yylval so that the parser actions
   * can have it:
   */
#ifdef XMLTP_GX
  p_lval->p_context = p_ctx;	/* for Bison "pure_parser" */
#else
  yylval.p_context = p_ctx;
#endif

  xmltp_ctx_assign_lexer_last_known_token(p_ctx, token_val);	/* used for debugging */

  return (token_val);		/* negative if unknown keyword */

} /* end of sf_match_tag() */




#ifdef XMLTP_GX
static int sf_get_value(YYSTYPE *p_lval, void *p_ctx)
#else
static int sf_get_value(void *p_ctx )
#endif
{
  int	     c		= 0,
  	     prev_c	= 0;
  int	     trunc_flag = 0;
  char	     sbuf[MAX_ONE_STRING] = "\0\0\0[not init]\0\0\0",
  	    *p = sbuf;

  while (1) {
	c = xmltp_ctx_get_input_char(p_ctx);
	if (c == -1) {
		xmltp_ctx_lexer_error(p_ctx, "unexpected EOF in str_value", sbuf);
		return (-1);	/* unexpected EOF */
	}
	if ('<' == c  &&  prev_c != '\\') {
		break;
	}
	prev_c = c;

	if (!trunc_flag  &&  p >= (sbuf + sizeof(sbuf) - 1)  ) {
		*p = '\0';
		xmltp_ctx_lexer_error(p_ctx, "str_value too long, truncated", sbuf);
		trunc_flag = 1;
	}
	if (!trunc_flag) {
		*p = (char) c;
		p++;
	}
  }
  if (!trunc_flag) {
	*p = '\0';
  }

  /* The current p_ctx->b_value_follows will decide which buffer
   * of the context will hold the value...
   */  
  xmltp_ctx_assign_lexer_str_value(p_ctx, sbuf);

  /* xmltp_ctx_get_lexer_value(p_ctx) return the address of the
   * appropriate buffer.  This depends on p_ctx->b_value_follows...
   * The parser will get the right string (value) because each
   * buffer has a different address.
   */  
#ifdef XMLTP_GX			/* for Bison "pure_parser" */
  p_lval->str_val = xmltp_ctx_get_lexer_value(p_ctx);
#else
  yylval.str_val = xmltp_ctx_get_lexer_value(p_ctx);
#endif

  /* Here, we assign a special value to p_ctx->b_value_follows
   * to change the behavior of xml_lex_yylex1() in the next call.
   * The lexer will find a (ending) tag in the table of keywords.
   */  
  xmltp_ctx_assign_lexer_value_follows(p_ctx, VALUE_FOLLOWS_HAS_ENDED);

  return (STRVAL);

} /* end of sf_get_value() */





#ifdef XMLTP_GX
static int xml_lex_yylex1(YYSTYPE *p_lval, void *p_ctx)
#else
static int xml_lex_yylex1(void *p_ctx)
#endif
{
  static int b_checked_keyword_table_done = 0;	/* at init: not done yet */
  char	*p_errmsg = NULL;
  int	c = 0;
  int	token_val = -1;

  /* For explanations on the effects of the state variable 
   * p_ctx->b_value_follows, see the comments in sf_get_value().
   *
   * The two following checks are made on this state variable...
   */
  if (xmltp_ctx_check_lexer_value_ended(p_ctx ) ) {
#ifdef XMLTP_GX
  	token_val = sf_match_tag( p_lval, p_ctx );
#else
 	token_val = sf_match_tag( p_ctx );
#endif
	return (token_val);
  }

  if (b_checked_keyword_table_done != 1) {
	b_checked_keyword_table_done = 1;
	p_errmsg = sf_check_keywords_table();
  	if (p_errmsg != NULL) {
  		xmltp_ctx_lexer_error(p_ctx, "ERROR from sf_check_keywords_table():", p_errmsg);
  		b_checked_keyword_table_done = -2;
  		return (-2);
  	}
  }

  if (xmltp_ctx_check_lexer_value_follows(p_ctx ) ) {
#ifdef XMLTP_GX
  	token_val = sf_get_value( p_lval, p_ctx );
#else
  	token_val = sf_get_value( p_ctx );
#endif
	return (token_val);
  }

  while (1) {
	switch (c = xmltp_ctx_get_input_char(p_ctx)) {
	case -1:		/* replace EOF by -1. jft, 2002feb03 */
		return (0);
	case '\t':		/* white space, skip them */
	case ' ':
	case '\r':		/* CR is also white space */
		continue;

	case '\n':		/* still white space, skip it */
#ifndef XMLTP_GX
		yylineno++;
#endif
		continue;

	case '<':
#ifdef XMLTP_GX
		token_val = sf_match_tag( p_lval, p_ctx );
#else
		token_val = sf_match_tag( p_ctx );
#endif
		return (token_val);

	default:
		break;
	} /* end switch */

	return (c);	/* probably a syntax error, parser will decide */
	
  } /* end of while */

  return (-2);	/* impossible */
  
} /* end of xml_lex_yylex1() */





static void debug_tokens(int token)
{
static 	int   prev_lineno = -1;
	char *p_token_name = NULL;
	char  buf[30] = "[buf]";

#ifndef XMLTP_GX
  if (prev_lineno != yylineno) {
  	prev_lineno = yylineno;
  	fprintf(stderr, "\nline %d ", yylineno);
  }
#endif
  if (((p_token_name = xmltp_lex_get_name_from_token2_val(token) )   == NULL)
   && ((p_token_name = xmltp_lex_get_keyword_from_token_val(token) ) == NULL) ) {
	if (token >= ' '  &&  token < 127)
		sprintf(buf, "%c", token);
	else 
		sprintf(buf, "x%02x", token);
	p_token_name = buf;
  }
  fprintf(stderr, " %s", p_token_name);
}



/* ---------------------------------------------- PUBLIC function: */

#ifdef XML2DB	   /* xmltp_lex_get_single_thread_context() must NOT */
		   /* be used by a multi-threaded program. */
void *xmltp_lex_get_single_thread_context()
/*
 * Called by: 	single thread main program
 *
 */
{
/* special function used for single-thread version.
 * Good for all "xml2db.h" programs, like "xml2syb".
 */
  if (NULL == s_p_single_parser_context) {
	s_p_single_parser_context = xmltp_ctx_create_new_context();

  	printf("\n%.20s single-thread version running, s_p_single_parser_context=%x\n",
  		__FILE__, s_p_single_parser_context);
  }
  return (s_p_single_parser_context );

} /* end of xmltp_lex_get_single_thread_context() */
#endif



/* ---------------------------------------------- public yylex() function: */

#ifdef XMLTP_GX
/* The order of args yylex(YYSTYPE *p_lval, void *p_ctx) is required by the Bison
 * "pure_parser" and YYLEX_PARAM define.
 */
int yylex(YYSTYPE *p_lval, void *p_ctx)
#else
int yylex()	    /* lexical analysis function: returns a token value */
#endif
{
  int	token = -1;

#ifdef XMLTP_GX
  token = xml_lex_yylex1( p_lval, p_ctx );
#else
  token = xml_lex_yylex1( xmltp_lex_get_single_thread_context() );
#endif

  if (s_debug_level >= 128) {
	debug_tokens(token);
  }

  return (token);

} /* end of yylex() */





int yyerror(char *s)
{
#ifdef YYERROR_PRINT
	fprintf(stderr, "%s\n", s);	/* KEEP this. SEE note below */
#endif

#ifndef XML2DB
	/* Ideally, this function should receive p_ctx as one of its argument,
	 *
	 * 	int yyerror(char *s, void *p_ctx)
	 *
	 * but, both Yacc and Bison generate source code for the calls and they
	 * do not generate p_ctx as an argument in yyerror() calls.
	 *
	 * The following cannot be done:
	 *
	 * 	xmltp_ctx_lexer_error( p_ctx, "yyerror():", s);
	 *
	 * NOTE:
	 * Output on stderr seems to be the best thing that can be useful
	 * because of the multithreading requirements.
	 *
	 * A more complex solution would be to use semaphore or mutex to
	 * acquire the current context... Maybe in a future version.
	 */
#else
	/* For the single-thread programs like "xml2syb", the following trick
	 * is OK.  The multi-thread version would need p_ctx as argument!
	 */
	xmltp_ctx_lexer_error( xmltp_lex_get_single_thread_context(),
				"yyerror():", s);
#endif
	
	return (0);

} /* end of yyerror() */



/* ------------------------------------------ end of xmltp_lex.c ------------ */
